1031 FRI

상속 : 필드, 메서드를 하위 클래스에 전달한다, 코드 재사용성, 중복 제거를 위함, 다형성

this : 현재 클래스 자신
super : 현재 클래스 기준 부모 클래스
상속받은 자식 클래스를 객체로 생성하면 부모 객체가 먼저 생성되고 자식 객체가 생성된다.

클래스 상속 : 단일 상속
인터페이스 : 다중 구현 가능 // 인터페이스끼리 상속은 다중 상속이 가능하다. interfaceA extends interfaceB, interfaceC, ..

메서드 오버라이딩 : 메서드 재정의, 상속 관계에서 부모의 메서드를 자식이 다시 정의
메서드 오버로딩 : 이름이 같은 메서드인데 메서드 타입, 파라미터와 동작이 다를 경우

형변환
작은 범위 -> 큰범위 : 자동 형변환 (업캐스팅)
큰 범위 -> 작은 범위 : 강제 형변환 (다운캐스팅) // 조건 : 원래 하위 클래스 객체였지만 상위 클래스 객체로 형변환 된 객체가 다시 하위 클래스로 변환되는 경우

API : application programming interface // 연동하는 프로그램을 대부분 API라고 부른다. (다른 서버, 프로그램 등) ex : 네이버 지도 api

봉인된 인터페이스, 클래스 (JAVA 15부터)
public sealed interface A permits B { ... }
public sealed class A permits B {...}
B만 A의 하위로 올 수 있다.

DAO : DataAccessObject, DB 접근 로직 담당 
DTO : DataTransformObject, 계층 간 데이터 전송용



<중첩 선언과 익명 객체>
인터페이스 - 익명 객체 - 람다식은 모두 이어진다.
중첩 클래스 : 클래스 내부에 선언한 클래스
외부에서는 중첩 클래스를 감춘다, 복잡성을 줄이지만 외부에서 알 수 없다.

중첩 클래스 : 멤버 클래스, 로컬 클래스

멤버 클래스 : 인스턴스 멤버 클래스, 정적 멤버 클래스
- 인스턴스 멤버 클래스 
class A { class B {...} } //A 객체를 생성해야 B 객체 생성 가능 (필드와 비슷하게 사용)
- 정적 멤버 클래스
class A { static class B {...} } //A 객체를 생성하지 않아도 B 객체 생성 가능 (static이기 때문)
내부 static 클래스가 public일 경우 다른 클래스에서도 내부 클래스 사용 가능

로컬 클래스 
class A { void method() { class B {...} } } //method()가 실행될 때만 B 객체 생성 가능

중첩 인터페이스 : 거의 사용할 일이 없다.

--------------------------------------------------------------------------------------------------------


익명 객체 : 이름이 없는 객체
명시적으로 클래스를 선언하지 않기 때문에 쉽게 객체를 생성 가능
익명 객체는 클래스를 상속하거나 인터페이스를 구현해야만 생성 가능

- 익명 상속 객체 : 클래스를 상속해서 만들 경우 // 부모 클래스를 상속받아 생성된다.
- 익명 구현 객체 : 인터페이스를 구현해서 만들 경우


익명 객체 사용 시 중요할 점 : 사용 후 마지막 괄호에 ; 를 붙여야 한다.
익명 객체 사용 이유 : 일회성 객체일 떄를 위하여 (한 번만 사용되는 객체일 때 익명 객체 생성)

public static class Tire{
  void roll(){
      System.out.println("일반 타이어가 굴러갑니다.");
  }
}
위의 Tire 클래스는 상위 클래스이며 이것을 통해 익명 클래스를 생성할 수 있다.

Tire tire1 = new Tire(){
    @Override
    void roll() {
        System.out.println("익명 상속 Tire 객체의 바퀴가 굴러갑니다.");
    }
};
tire1은 Tire 타입의 부모 클래스이고, 익명 객체를 정의하며 Tire의 하위 타입 객체를 메서드 오버라이딩하며 생성



public class EX17 {
    public static void main(String[] args) {
        Car car = new Car();
        car.run1();
        car.run2();
        car.run3(new Tire(){
            @Override
            void roll() {
                System.out.println("익명 상속 객체 Tire이 run3 메서드를 통해 굴러갑니다.");
            }
        });
    }


    public static class Tire{
        void roll(){
            System.out.println("일반 타이어가 굴러갑니다.");
        }
    }
    
    public static class Car{

        //인스턴스 멤버 클래스, Tire을 상속받아 바로 재정의 
        Tire tire1 = new Tire(){
            @Override
            void roll() {
                System.out.println("익명 상속 Tire 객체의 바퀴가 굴러갑니다.");
            }
        };
        
        //일반 클래스, 상위인 Tire만 정의
        Tire tire2 = new Tire();

        void run1(){
            tire1.roll(); // 익명의 하위 클래스 roll 사용
            tire2.roll(); // 상위인 tire의 roll 사용
        }

        void run2(){
            Tire tire = new Tire(){
                @Override
                void roll() {
                    System.out.println("로컬 클래스 속 익명 상속 Tire 객체가 굴러갑니다.");
                }
            };
            tire.roll();
        }

        void run3(Tire tire){
            tire.roll();
        }
    }
}
--------------------------------------------------------------------------------------------------------

람다 표현식 : 함수형 인터페이스를 익명으로 구현하는 간결한 방법
익명 객체 - 클래스, 인터페이스를 이용해 익명의 일회성 하위 객체 생성 가능
람다 표현식은 그 중 인터페이스를 이용하는 방법이다.

Runnable 인터페이스를 이용한 람다 표현식

Runnable task1 = new Runnable() {
    @Override
    public void run() {
        System.out.println("익명 클래스로 실행");
    }
};

Runnable task2 = () -> System.out.println("람다로 실행"); //run 메서드를 구현
--------------------------------------------------------------------------------------------------------

라이브러리
JAR : 클래스, 인터페이스의 바이트 코드 파일 (.class)들이 압축되어 있다.
외부에 스프링 부트로 JAR 배포
개발 시 라이브러리를 사용하려면 라이브러리 JAR 파일을 classPath에 추가해야 한다. (클래스를 찾기 위한 경로)

클래스 패스에 라이브러리 추가 방법
- 터미널로 실행 시 classPath 환경 변수에 경로를 추가

- 이클립스로 실행 시 Properties - java build path - libraries - classPath 


jdk : java development kit // 자바로 프로그램을 설계하기 위해 존재
jre : java runtime environment // 자바로 만든 프로그램을 사용하기 위해서 반드시 필요
과거에는 jdk와 jre가 분리되어있었지만 현재는 jdk 내부에 jre가 들어가있다.



클린 코드, 가독성
--------------------------------------------------------------------------------------------------------
