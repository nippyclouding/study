1107 FRI
---------------------------------------------------------------------------------------------------------------------
스트림
하나씩 흘러가면서 처리된다는 의미
이전 컬렉션, 배열 반복 처리 : for, iterator 이용
for문, iterator은 객체 밖에서 수행(외부 반복자), 스트림은 객체 내부에서 수행한다.(내부 반복자)

Stream의 특징
- 내부 반복자 : 처리 속도가 빨라 병렬 처리에 효율적 // 멀티 코어 CPU를 최대한 활용하기 위해 요소들을 분배하여 병렬 작업이 가능
- 람다식으로 처리 가능
- 중간 처리, 최종 처리 => 파이프 라인 형성 가능

*set, list 등 컬렉션에는 참조 자료형만 들어갈 수 있다. 스트림도 컬렉션을 이용하기에 참조 자료형만 대상으로 가질 수 있다.

public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        set.add("1");
        set.add("2");
        set.add("3");
        set.add("4");

        Stream<String> stream = set.stream(); //스트림 얻기, 순차 스트림 : 단일 스레드에서 순서대로 처리
        stream.forEach(name -> System.out.println(name)); 
        //set.stream().forEach(n -> System.out.println(n));로 줄일 수 있다.
    }

public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("1");
        list.add("2");
        list.add("3");
        list.add("4");
        list.add("5");

        Stream<String> stream = list.parallelStream(); //병렬 스트림 얻기 : 멀티 스레드에서 빠른 속도로 병렬 처리
        stream.forEach(name -> {
            System.out.println(Thread.currentThread().getName());
        });

        //list.parallelStream().forEach(n -> System.out.println(Thread.currentThread().getName())); 으로 줄일 수 있다.
    }

중간 처리, 최종 처리
스트림이 연결되어있는 것을 스트림 파이프라인 이라고 한다.
컬렉션의 오리지널 스트림 뒤에는 필터링 중간 스트림이 연결될 수 있고 그 뒤 매핑 중간 스트림이 연결될 수 있다.

컬렉션, 배열 -> 오리지널 스트림 -> 중간 처리 (필터링 중간 스트림, 매핑 중간 스트림) -> 최종 집계 처리, 결과

파이프라인의 맨 끝에는 반드시 최종 처리 부분이 있어야 한다. 
Stream<Student> studentStream = list.stream();
IntStream scoreStream = studentStream.mapToInt(s -> s.getScore());
double avg = scoreStream.average().getAsDouble();

public class EX44 {
    public static void main(String[] args) {
        //1.
        List<Student> list = Arrays.asList(
                new Student("1", 10),
                new Student("2", 20),
                new Student("3", 30)
        );

        Stream<Student> stream1 = list.stream();
        IntStream scoreStream = stream1.mapToInt(s -> s.score);
        double avg = scoreStream.average().getAsDouble();
        
        //2.
        double avg2 = list.stream().mapToInt(s2 -> s2.score).average().getAsDouble();
    }
    @AllArgsConstructor
    static class Student{
        String name;
        int score;
    }
}

public class EX45 {

    public static void main(String[] args) {
        List<Product> list = new ArrayList<>();
        for(int i=1; i<=5; i++){
            Product p = new Product(i, "상품" + i, "comp", (int) (1000* Math.random()));
            list.add(p);
        }

        Stream<Product> stream = list.stream();
        stream.forEach(p -> System.out.println(p));
    }

    @AllArgsConstructor @Data
    static class Product{
        int pro;
        String name;
        String company;
        int price;
    }
}

public class EX46 {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student("1", 50));
        list.add(new Student("1", 51));
        list.add(new Student("1", 52));

        //리스트를 스트림 객체로 변환, 객체의 데이터를 int로 변환, 반복 출력 
        list.stream()
                .mapToInt(ssss -> ssss.score).
                forEach(ss -> System.out.println(ss));
    }
    @AllArgsConstructor @Data
    static class Student{
        String name;
        int score;
    }
}

public class EX47 {
    public static void main(String[] args) {

        //배열 -> 리스트 변환
        int[] arr = {1, 2, 3};
        List<Integer> list = Arrays.asList( // list로 변환
                Arrays.stream(arr).boxed()
                        .toArray((Integer[]::new))); //Integer 배열로 변환

        //리스트 -> 배열 변환
        int[] arr2 = list.stream().mapToInt(i->i).toArray();
    }

}
---------------------------------------------------------------------------------------------------------------------
데이터 입출력

데이터(파일) 입출력
네트워크 입출력
데이터베이스 입출력
- 모두 라이브러리이다.

public class EX48 {
    public static void main(String[] args)  {
        OutputStream os = null;
        try{
            os = new FileOutputStream("/Users/aaa/Desktop/hello.rtf");
            byte a = 10;
            byte b = 20;
            byte c = 30;

            os.write(a);
            os.write(b);
            os.write(c);

            os.flush();

        }catch (IOException e){
            e.printStackTrace();
        }finally {
            try{
                os.close();
            }catch (IOException e) {}
        }
    }
}

public class EX48 {
    public static void main(String[] args) throws IOException {
        OutputStream os = null;
        try{
            os = new FileOutputStream("/Users/aaa/Desktop/hello.rtf");
            byte a = 10;
            byte b = 20;
            byte c = 30;

            os.write(a);
            os.write(b);
            os.write(c);

            os.flush();

        }catch (IOException e){
            e.printStackTrace();
        }finally {
            try{
                os.close();
            }catch (IOException e) {}
        }

        InputStream is = null;
        try{
            is = new FileInputStream("/Users/aaa/Desktop/hello.rtf");
            int data = 0;
            while((data=is.read())!=-1) System.out.println(data);
        }catch (FileNotFoundException e){
            e.printStackTrace();
        }catch (IOException e){
            e.printStackTrace();
        }finally {
            is.close();
        }
    }
}

public class EX49 {
    public static void main(String[] args) throws IOException {

        try{
            Writer writer = new FileWriter("/Users/aaa/Desktop/hello.rtf");

            char a = 'a';
            writer.write(a);
            char b = 'b';
            writer.write(b);

            char[] arr = {'c', 'd', 'e'};
            writer.write(arr);

            writer.write("FGH");
            writer.flush();

            writer.close();
        }catch (IOException e){
            e.printStackTrace();
        }
        
        try{
            Reader reader = null;
            
            reader = new FileReader("/Users/aaa/Desktop/hello.rtf");
            while (true){
                int data = reader.read();
                if(data == -1) break;
                System.out.println((char)data);
            }
            reader.close();
            System.out.println();
            
            reader = new FileReader("/Users/aaa/Desktop/hello.rtf");
            char[] data = new char[100];
            while(true){
                int num = reader.read(data);
                if(num == -1) break;
                for(int i=0; i<num; i++) System.out.println(data[i]);
            }reader.close();
        }catch (FileNotFoundException e){
            e.printStackTrace();
        }catch (IOException e){
            e.printStackTrace();
        }
        
    }
}
---------------------------------------------------------------------------------------------------------------------
네트워크 입출력 후 자바와 외부 API를 연동하는 방법을 익힐 예정
