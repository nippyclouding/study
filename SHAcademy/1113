1113 THUR

복습 - SQL
union을 실행하면 성능이 느려진다 => 가급적이면 사용하지 말기

오라클은 concat으로 여러 문자열을 합칠 때 concat을 중첩으로 사용해야 한다.
concat(empno, concat(' : ', ename)) 
=> 중첩 사용이 번거롭기 때문에 concat 대신 문자열을 합칠 때 || 을 사용하는 것이 편리하다.

mysql은 연달아서 사용 가능
concat(empno, ' : ' , ename)

select to_char(sysdate, 'yyyy/mm/dd hh24:mi:ss') as 현재날짜시간
from dual

to_char : 문자로 변경, 'yyyy ... ' - char 형태로 출력할 때 출력하는 포멧을 전달 (출력 포멧 전달)   
to_date : 날짜로 변경, 매개변수 형태가 'yyyy ..' 형태이다는 것을 전달 (입력 포멧 전달)

where 을 먼저 실행하고 group by를 이후에 수행, 그 뒤 having을 수행한다.

고급 그룹화
<rollup>
소계와 총합계를 자동으로 생성, 계층적 집계를 만든다.
오른쪽에서 왼쪽으로 단계적으로 소계 생성
ROLLUP(A, B, C) → (A,B,C) + (A,B) + (A) + ()
계층 구조가 있을 때 유용 (예: 연도 → 월 → 일)

SELECT deptno, job, COUNT(*), SUM(sal)
FROM emp
GROUP BY ROLLUP(deptno, job);
```

### 실행 결과
```
DEPTNO  JOB        COUNT  SUM(SAL)
------  ---------  -----  --------
10      CLERK      1      1300
10      MANAGER    1      2450
10      PRESIDENT  1      5000
10      NULL       3      8750     ← 10번 부서 소계
20      ANALYST    2      6000
20      CLERK      2      1900
20      MANAGER    1      2975
20      NULL       5      10875    ← 20번 부서 소계
30      CLERK      1      950
30      MANAGER    1      2850
30      SALESMAN   4      5600
30      NULL       6      9400     ← 30번 부서 소계
NULL    NULL       14     29025    ← 전체 총계


<cube>
모든 가능한 조합의 소계를 생성, rollup보다 더 많은 소계를 생성한다.

모든 차원의 조합에 대한 소계 생성
CUBE(A, B) → (A,B) + (A) + (B) + ()
컬럼 개수가 N개면 2^N개의 그룹 생성
데이터가 많으면 결과도 매우 많아진다.

SELECT deptno, job, COUNT(*), SUM(sal)
FROM emp
GROUP BY CUBE(deptno, job);
```

### 실행 결과
```
DEPTNO  JOB        COUNT  SUM(SAL)
------  ---------  -----  --------
10      CLERK      1      1300
10      MANAGER    1      2450
10      PRESIDENT  1      5000
10      NULL       3      8750     ← 10번 부서 소계
20      ANALYST    2      6000
20      CLERK      2      1900
20      MANAGER    1      2975
20      NULL       5      10875    ← 20번 부서 소계
30      CLERK      1      950
30      MANAGER    1      2850
30      SALESMAN   4      5600
30      NULL       6      9400     ← 30번 부서 소계
NULL    ANALYST    2      6000     ← 직무별 소계 (ROLLUP에는 없음!)
NULL    CLERK      4      4150     ← 직무별 소계
NULL    MANAGER    3      8275     ← 직무별 소계
NULL    PRESIDENT  1      5000     ← 직무별 소계
NULL    SALESMAN   4      5600     ← 직무별 소계
NULL    NULL       14     29025    ← 전체 총계


집계함수 (그룹핑, 다중행 함수)
-null을 제외하고 연산한다.
sum(comm) : comm이 null이 아닌 것만 합계
avg(comm) : comm이 null이 아닌 것만 평균 ... 
count, max, min, 분산, 표준 편차 모두 null이 아닌 것을 대상으로 한다.

주의 : sum(*) : null까지 포함
count(comm)은 null을 제외하지만
count(*)은 null을 포함한다.
일반적으로 count에서는 null까지 포함하기 때문에 count(*)를 사용하기


sql 설계
1. 어디에서 (from)
2. 어떻게 (where)
3. 그룹핑 + 그룹핑 조건 (having)
4. 무엇을 (select)
5. 정렬 (order by)


------------------------------------------------------------------------------------------
<JOIN>

-- 오라클의 기본 문법으로는 조인 시 mysql과 다르게 join .. on .. 의 on 절이 없다.
-- 오라클에서는 outer join 시 + 기호를 사용한다.

<LEFT JOIN> 
왼쪽에 조건을 두려면 오른쪽에 (+)를 둔다.
select a.empno, a.ename, a.mgr, b.empno MGR_EMPNO, b.ename MGR_ENAME
from emp a, emp b
where a.mgr = b.empno(+); -- left join

<RIGHT JOIN>
오른쪽에 조건을 두려면 왼쪽에 (+)를 둔다.
select a.empno, a.ename, a.mgr, b.empno MGR_EMPNO, b.ename MGR_ENAME
from emp a, emp b
where a.mgr(+) = b.empno; -- right join


--  오라클의 기본 문법에는 join on 절이 없지만 표준 문법으로 사용 지원이 된다.
select e.ename, e.deptno
from emp e
    join dept d
    on e.deptno = d.deptno
    order by e.empno;

-- 오라클의 기본 문법으로는 조인 시 mysql과 다르게 join .. on .. 의 on 절이 없다.
-- 오라클에서는 outer join 시 + 기호를 사용한다.

select a.empno, a.ename, a.mgr, b.empno MGR_EMPNO, b.ename MGR_ENAME
from emp a, emp b
where a.mgr = b.empno(+); -- left join

select a.empno, a.ename, a.mgr, b.empno MGR_EMPNO, b.ename MGR_ENAME
from emp a, emp b
where a.mgr(+) = b.empno; -- right join





<서브쿼리>
-- 서브쿼리
-- 단일행 서브쿼리 : 서브쿼리 안에서 함수 사용
select e.empno, e.ename, e.job, e.sal, d.deptno, d.dname, d.loc
from emp e, dept d
where e.deptno = d.deptno
    and e.deptno = 20
    and e.sal > (select avg(sal) from emp); --avg(sal)은 단일 행을 반환한다.

-- 다중행 서브쿼리 : 여러 행일 경우
select *
from emp
where sal in (
            select max(sal)
            from emp
            group by deptno
);
--max(sal)을 포함하고 있는 sal의 데이터 출력

-- from절에 들어가는 서브쿼리 = 인라인 뷰 (뷰 : 가상 테이블)
-- 인라인 뷰 : 실제 뷰는 아니지만 from 절에서 뷰처럼 사용하는 임시 뷰 // 뷰는 객체처럼 생성해서 저장소에 둘 수 있다.

select ee.empno, ee.ename, ee.deptno, d.dname, d.loc
from (select * from emp where deptno = 10) ee,
     (select * from dept) d
where ee.deptno = d.deptno;

-- with : from절 서브쿼리 먼저 생성
with
e as (select * from emp where deptno = 10),
d as (select * from dept)
select e.empno, e.ename, e.depton, d.dname, d.loc
from e
    join d
    on e.deptno = d.deptno;
    
    
