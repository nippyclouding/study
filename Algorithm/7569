백준 7569 토마토

https://www.acmicpc.net/problem/7569

다시 풀어보기

import java.util.*;
import java.io.*;

public class Main{
    static int[] dx = {1, 0, -1, 0, 0, 0};
    static int[] dy = {0, 1, 0, -1, 0, 0};
    static int[] dz = {0, 0, 0, 0, 1, -1};

    public static void main(String[] args) throws Exception{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        //입력
        String[] input = br.readLine().split(" ");
        int columns = Integer.parseInt(input[0]); //가로
        int rows = Integer.parseInt(input[1]); //세로
        int height = Integer.parseInt(input[2]); //높이

        int[][][] board = new int[height][rows][columns];

        for(int i=0; i<height; i++){
            for(int j=0; j<rows; j++){
                String[] s = br.readLine().split(" ");
                for(int z=0; z<columns; z++) board[i][j][z] = Integer.parseInt(s[z]);
            }
        }

        //출력
        int result = bfs(board);
        System.out.println(result);
    }

    static int bfs(int[][][] board){
        int answer = 0;

        Queue<Pair> q = new ArrayDeque<>();

        //시작지점 찾기
        for(int i=0; i<board.length; i++){
            for(int j=0; j<board[i].length; j++){
                for(int z=0; z<board[i][j].length; z++){
                    if(board[i][j][z]==1){
                        Pair newP = new Pair(z, j, i, 0);
                        q.offer(newP);
                    }
                }
            }
        }

        //시작 지점 없으면 체크
        if(q.isEmpty()) {
        // 모든 칸이 -1인지 확인 (토마토가 아예 없는 경우)
        for(int i=0; i<board.length; i++){
            for(int j=0; j<board[i].length; j++){
                for(int z=0; z<board[i][j].length; z++){
                    if(board[i][j][z] == 0) return -1; // 익지 않은 토마토가 있으면 -1
                    }
                }
            }
            return 0; // 모든 칸이 -1이면 0
        }

        //시작지점을 찾는다면 BFS 수행
        while(!q.isEmpty()){
            Pair poll = q.poll();

            answer = poll.cnt;

            for(int i=0; i<6; i++){
                int nx = poll.x + dx[i];
                int ny = poll.y + dy[i];
                int nz = poll.z + dz[i];

                if(nx<0 || ny<0 || nz<0 || nx>= board[0][0].length || ny>=board[0].length || nz >= board.length) continue;
                if(board[nz][ny][nx] != 0) continue;

                Pair newP = new Pair(nx, ny, nz, poll.cnt+1);

                board[nz][ny][nx] = 1;
                q.offer(newP);
            }



        }
        // BFS가 끝난 뒤 0이 남아있다면
        for (int i=0; i< board.length; i++){
            for (int j=0; j<board[i].length; j++){
                for (int z=0; z<board[i][j].length; z++)
                    if (board[i][j][z] == 0) return -1;
            }
        }


        return answer;
    }
    static class Pair{
        int x;
        int y;
        int z;
        int cnt;
        public Pair(int x, int y, int z, int cnt){
            this.x = x;
            this.y = y;
            this.z = z;
            this.cnt = cnt;
        }
    }
}
