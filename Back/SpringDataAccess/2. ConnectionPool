ConnectionPool & DataSource
1. ConnectionPool 커넥션 풀

DB 드라이버가 DB와 연결을 맺는 과정 
1 : Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD)로 연결
2 : DB 드라이버는 DB와 TCP/IP 커넥션을 연결 (3 way handShake)
3 : TCP/IP 커넥션 연결 후 ID, PW, 기타 부가 정보 등을 DB에 전달
4 : DB는 ID, PW를 통해 내부 인증, 내부에 DB 세션을 생성
5 : DB는 커넥션 생성이 완료되었다는 응답을 DB 드라이버에게 보낸다.
6 : DB 드라이버는 커넥션 객체를 생성하여 애플리케이션 로직에게 반환한다.

커넥션 = 클라이언트 - DB 서버를 연결하는 '다리' 역할

한계 : 커넥션을 새로 만드는 것은 복잡하고 시간도 많이 소모된다.
해결 : 커넥션 풀이라는 곳에 커넥션을 미리 생성, 보관한 뒤 필요할 때 커넥션 풀에서 커넥션을 가져와 사용한다.

미리 커넥션 풀 속에 커넥션을 생성해두면 클라이언트는 DB 드라이버를 거쳐 커넥션을 사용하는 것이 아니라 
커넥션 풀에서 바로 직접 가져다 사용이 가능하다.

1 : 커넥션 풀에서 커넥션 조회
2 : 커넥션이 있을 경우 커넥션을 꺼내어 바로 사용한다.
3 : 커넥션을 모두 사용한 뒤 커넥션 풀에 반환할 때 커넥션을 close하지 않고 커넥션 풀에 반환해야 한다.

* 커넥션 풀에 보관하는 커넥션은 기본 10개이지만 서버 스펙과 환경에 따라 모두 상이하다.
* 커넥션 풀은 구현하기 간단하지만(커넥션을 담는 리스트 형태) 뛰어난 성능과 간편함으로 오픈소스 커넥션 풀을 사용한다. 주로 HikariCP를 사용

정리 : 클라이언트가 커넥션을 획득하는 방법
- DriverManager을 통하여 커넥션을 생성(JDBC DriveManager)
Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD)
- 커넥션 풀에 등록되어 있는 커넥션을 사용 (HikariCP)

------------------------------------------------------------------------------------------------------------------------------

2. DataSource 데이터 소스

커넥션 획득 방법 : DriverManager.getConnection, HikariCP 등 ..

문제 : 커넥션 사용 방법을 교체하려면 관련 코드를 모두 수정해야 한다. (OCP, DIP 위반)
해결 : 커넥션 획득 방법을 추상화 
=> DataSource 인터페이스 (javax.sql.Datasource)

public interface DataSource{//핵심 기능 : 커넥션 조회
  Connection getConnection() throws SQLException;
}

문제 : DataSource 인터페이스를 사용하면 DriverManager.getConnection()을 사용할 수 없다.(인터페이스를 구현하지 않는다.)
해결 : Spring의 지원 - DataSource 인터페이스를 구현하는 DriverManagerDataSource 클래스를 제공

DataSource 인터페이스 구현체 = HikariCP(커넥션 풀), DriverManagerDataSource(직접 커넥션 생성) .. 

------------------------------------------------------------------------------------------------------------------------------
커넥션 생성 방법 
- DriverManage로 직접 커넥션 생성 DriverManager.getConncetion(URL, USERNAME, PASSWORD);
- DataSource 인터페이스 이용
  => 직접 커넥션 생성 : DataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);  //설정
                    Connection con = dataSource.getConnection(); //사용
  => 커넥션 풀 생성, 커넥션 조회 : HikariDataSource dataSource = new HikariDataSource();
                             dataSource.setJdbcUrl(URL);
                             dataSource.setUsername(USERNAME);
                             dataSource.setPassword(PASSWORD);
                             dataSource.setMaximumPoolSize(10);
                             dataSource.setPoolName("pool1");
                             Connection con = dataSource.getConnection(); //커넥션 풀 사용, conn0, conn1 ... conn9까지 커넥션 풀에 채운다.

------------------------------------------------------------------------------------------------------------------------------

<최종 코드 : DataSource를 이용한 DB 연결>

import hello.jdbc.domain.Member;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.support.JdbcUtils;
import javax.sql.DataSource;
import java.sql.*;
import java.util.NoSuchElementException;
@Slf4j
public class MemberRespositoryV1 {
    private final DataSource dataSource;

    //생성자가 하나이기에 AutoWired 자동 적용
    //DataSource dataSource 파라미터에 외부에서(Service 계층 등) HikariCP 타입을 주입한다.
    public MemberRespositoryV1(DataSource dataSource) { 
        this.dataSource = dataSource;
    }
    //회원 저장
    public Member save(Member member) throws SQLException {
        String sql = "insert into member(member_id, money) values(?,?)";

        Connection connection = null;
        PreparedStatement preparedStatement = null;

        try{
            connection = getConnection();//커넥션 얻기
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, member.getMemberId());
            preparedStatement.setInt(2, member.getMoney());
            preparedStatement.executeUpdate();
            return member;
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, null);
        }
    }
    //회원 조회
    public Member findById(String memberId) throws SQLException {
        String sql = "select * from member where member_id = ?";

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try{
            connection=getConnection();
            preparedStatement= connection.prepareStatement(sql);
            preparedStatement.setString(1, memberId);

            resultSet=preparedStatement.executeQuery();

            if(resultSet.next()){
                Member member = new Member();
                member.setMemberId(resultSet.getString("member_id"));
                member.setMoney(resultSet.getInt("money"));
                return member;
            }else{
                throw new NoSuchElementException("member not found memberId=" + memberId);
            }
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, resultSet);
        }
    }
    //회원 수정
    public void update(String memberId, int money) throws SQLException {
        String sql = "update member set money =? where member_id = ?";

        Connection connection = null;
        PreparedStatement preparedStatement = null;

        try{
            connection = getConnection();//커넥션 얻기
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, money);
            preparedStatement.setString(2, memberId);

            int resultSize = preparedStatement.executeUpdate();
            log.info("resultSize = " +  resultSize);

        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, null);
        }
    }
    //회원 삭제
    public void delete(String memberId) throws SQLException {
        String sql = "delete from member where member_id=?";

        Connection connection = null;
        PreparedStatement preparedStatement = null;

        try{
            connection = getConnection();//커넥션 얻기
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, memberId);

            preparedStatement.executeUpdate();

        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, null);
        }
    }
    //연결 끊기
    private void close(Connection connection, Statement statement, ResultSet resultSet){
        JdbcUtils.closeResultSet(resultSet);
        JdbcUtils.closeStatement(statement);
        JdbcUtils.closeConnection(connection);
    }
    //연결 시작
    private Connection getConnection() throws SQLException{
        Connection connection = dataSource.getConnection();
        log.info("get connection={}, class={}", connection, connection.getClass());
        return connection;
    }
}

<변경 사항>
스프링은 JDBC 표준 인터페이스를 편리하게 닫을 수 있는 JdbcUtils 메서드를 제공한다.
복잡한 예외 처리 구문 없이 단순히 닫을 수 있다.
JdbcUtils.closeResultSet(resultSet);
JdbcUtils.closeStatement(statement);
JdbcUtils.closeConnection(connection);


<Repository Test>

import com.zaxxer.hikari.HikariDataSource;
import hello.jdbc.domain.Member;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.sql.SQLException;
import java.util.NoSuchElementException;
import static hello.jdbc.connection.ConnectionConst.*;
import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;
import static org.junit.jupiter.api.Assertions.*;
@Slf4j
class MemberRespositoryV1Test {
    MemberRespositoryV1 respository;

    @BeforeEach
    void beforeEach() throws Exception{
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(URL);
        dataSource.setUsername(USERNAME);
        dataSource.setPassword(PASSWORD);
        respository = new MemberRespositoryV1(dataSource);
    }

    @Test
    void crud() throws SQLException, InterruptedException{
        log.info("start");

        Member member = new Member("memberV0", 10000);
        respository.save(member);

        Member memberById = respository.findById(member.getMemberId());
        assertThat(memberById).isNotNull();

        respository.update(member.getMemberId(), 20000);
        Member updateMember = respository.findById(member.getMemberId());
        assertThat(updateMember.getMoney()).isEqualTo(20000);

        respository.delete(member.getMemberId());
        assertThatThrownBy(()->respository.findById(member.getMemberId())).isInstanceOf(NoSuchElementException.class);
    }
}


<HikariCP 인터페이스를 사용하여 DB를 접근한 부분>

@BeforeEach//각 테스트가 실행되기 직전에 한 번 호출
void beforeEach() throws Exception{
    HikariDataSource dataSource = new HikariDataSource();// MemberRepository에서 private final DataSource dataSource = new HikariDataSource() 가 적용된다.
    dataSource.setJdbcUrl(URL);
    dataSource.setUsername(USERNAME);
    dataSource.setPassword(PASSWORD);
    respository = new MemberRespositoryV1(dataSource); // HikariDataSource를 MemberRepository 생성자에 전달
}



테스트 로그 결과
get connection=HikariProxyConnection@..... wrapping conn0: url=jdbc:h2:tcp://localhost/~/test user=Sa
get connection=HikariProxyConnection@..... wrapping conn0: url=jdbc:h2:tcp://localhost/~/test user=Sa
get connection=HikariProxyConnection@..... wrapping conn0: url=jdbc:h2:tcp://localhost/~/test user=Sa
get connection=HikariProxyConnection@..... wrapping conn0: url=jdbc:h2:tcp://localhost/~/test user=Sa
get connection=HikariProxyConnection@..... wrapping conn0: url=jdbc:h2:tcp://localhost/~/test user=Sa
get connection=HikariProxyConnection@..... wrapping conn0: url=jdbc:h2:tcp://localhost/~/test user=Sa

1 : repository.save(member);에서 Hikari 커넥션 풀 속의 커넥션을 사용, save가 종료될 때 close로 커넥션을 풀에 반납
2 : Member memberById = respository.findById(member.getMemberId());에서 Hikari 커넥션 풀 속의 커넥션을 재사용, findById가 종료될 때 close로 커넥션을 풀에 반납
3 : respository.update(member.getMemberId(), 20000);에서 Hikari 커넥션 풀 속의 커넥션을 재사용, update가 종료될 때 close로 커넥션을 풀에 반납
4 : Member updateMember = respository.findById(member.getMemberId());에서 Hikari 커넥션 풀 속의 커넥션을 재사용, findById가 종료될 때 close로 커넥션을 풀에 반납
5 : respository.delete(member.getMemberId());에서 Hikari 커넥션 풀 속의 커넥션을 재사용, delete가 종료될 때 close로 커넥션을 풀에 반납
6 : assertThatThrownBy(()->respository.findById(member.getMemberId())).isInstanceOf(NoSuchElementException.class);에서 Hikari 커넥션 풀 속의 커넥션을 재사용, findById가 종료될 때 close로 커넥션을 풀에 반납
7 : HikariDataSource의 setMaximumPoolSize를 생략하면 기본적으로 10개의 커넥션이 커넥션 풀에 생성된다.

Point는 Hikari 커넥션 풀 속의 커넥션을 재사용하고 리포지토리의 메서드가 종료될 때 close로 커넥션을 풀에 반납하는 것이다.
DriverManagerDataSource를 사용하면 커넥션을 매 번 새로 생성하지만 커넥션 풀을 사용하면 커넥션을 재사용 할 수 있다.

------------------------------------------------------------------------------------------------------------------------------
