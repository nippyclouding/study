
<Transaction>

파일 저장이 아닌 DB에 저장하는 이유 : DB는 트랜잭션을 지원하기 때문이다.
트랜잭션 : 데이터베이스에서 작업의 기본 단위

ex) 5000원 거래 : A의 잔고를 5000원 감소, B의 잔고를 5000원 증가 
=> 두 가지 작업으로 이루어져 있다. 이 둘은 하나의 작업처럼 동작해야 한다. 

- Commit : 모든 작업이 성공하여 데이터베이스에 정상 반영
- Rollback : 작업 중 실패 요소가 있어 작업 시작 이전으로 되돌리는 동작

트랜잭션 ACID 
Atomicity 원자성 : 트랜잭션 내에서 실행한 작업들은 하나의 작업인 것처럼 모두 성공하거나 실패해야 한다.
Consistency 일관성 : 모든 트랜잭션은 일관성 있는 상태를 유지해야 한다.
Isolation 격리성 : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.
Duratibility 지속성 : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.

- 격리성을 완벽히 보장하기 위해서는 트랜잭션을 거의 순서대로 실행해야 한다.
=> 동시 처리 성능이 나빠진다. => ANSI 표준 : 트랜잭션의 격리 수준을 네 단계로 나누어 정의
Isolation level
1) READ UNCOMMITED 커밋되지 않은 상태로 읽기
2) READ COMMITTED 커밋된 상태에서 읽기
3) REPEATABLE READ 반복 가능한 읽기
4) SERIALIZABLE 직렬화 가능


-------------------------------------------------------------------------------------------------------------------------------------

<DB Session>

데이터베이스 연결 구조
1) 사용자의 DB 접근 : WAS, DB 접근 툴 등을 이용하여 DB 서버에 접근, 연결을 요청하여 커넥션을 맺는다.
2) DB 서버는 내부에 세션을 생성, 연결된 현재 커넥션을 통한 모든 요청은 이 세션을 이용해 실행한다.
3) 사용자가 커넥션을 닫거나 DBA가 세션 강제 종료 시 세션이 종료된다.

Session
- 클라이언트가 SQL을 커넥션을 통해 전달 시 SQL을 받아 실행하는 역할
- 트랜잭션 시작의 주체, Commit, Rollback을 통해 트랜잭션을 종료한다.
- 세션은 커넥션의 수만큼 만들어진다. 커넥션 풀에 커넥션이 n개 존재할 경우 세션도 n개 생성된다.

commit 관련 SQL
set autocommit true; : 자동 커밋, 설정하지 않으면 기본값으로 자동 커밋이 이루어진다.
쿼리를 하나 실행한 직후 자동으로 매번 커밋을 호출한다. 커밋, 롤백을 직접 호출하지 않아도 되지만 매번 자동으로 쿼리 한 단위씩 커밋이 되기 때문에 트랜잭션 기능을 이용하지 못한다.
set autocommit false; : 수동 커밋, '트랜잭션을 시작하다'와 같은 의미이다. 트랜잭션 끝에 commit이나 rollback을 써야 한다.

트랜잭션 예시
set autocommit false; //트랜잭션 시작
insert into member(member_id, money) values ('data3', 10000);
insert into member(member_id, money) values ('data4', 10000);
commit //트랜잭션 종료




-------------------------------------------------------------------------------------------------------------------------------------
Transaction 사용
- 데이터를 변경하는 쿼리를 실행하고 commit을 하지 않으면 해당 데이터는 '임시로' 저장된다.
- 해당 트랜잭션을 시작한 세션의 유저에게만 변경 데이터가 보여지고, 다른 세션 유저에게는 데이터 변경이 반영되지 않은 채로 보여진다. (변경 : 등록, 수정, 삭제)

ex 1) 
user 1의 테이블 수정, commit하지 않은 상태
user 2가 테이블을 조회하면 데이터가 변경되지 않은 채로 조회된다.
user 1의 commit이 이루어지면 user 2의 테이블 조회에도 데이터가 변경되어 조회된다.
user 1이 데이터를 수정 중 변경이 잘못 이루어지면 rollback을 사용해 변경 이전으로 되돌릴 수 있다.


ex 2)
SQL 트랜잭션 실습(H2 DB)
-case 1 : 계좌 이체 성공
-case 2 : 계좌 이체 실패 - commit
-case 3 : 계좌 이체 실패 - rollback

drop table member if exists cascade;
create table member(
                       member_id varchar(10),
                       money integer not null default 0,
                       primary key (member_id)
);


<case 1 : 계좌 이체 성공>

set autocommit true;
    delete from member;
    insert into member(member_id, money) values('memberA', 10000);
    insert into member(member_id, money) values('memberB', 10000);

select * from member; : user1, 2 모두 같은 결과창이 보여진다.

user 1 : 트랜잭션 시작
set autocommit fasle;
    update member set money=10000 - 2000 where member_id = 'memberA';
    update member set money=10000 + 2000 where member_id = 'memberB';


commit을 하지 않은 상태에서 
user 1의 select : update 쿼리가 적용된 결과가 보여진다. (임시 저장)
user 2의 select : update 쿼리가 적용되지 않은 기존의 결과가 보여진다.

user 1의 commit; 이후
user 1, 2는 둘 다 update 쿼리가 적용된 결과가 보여진다. 
(user 1, 2 = 세션 1, 2로 각각 접속했다고 가정)

<case 2 : 계좌 이체 실패 - commit>

user 1 : 트랜잭션 시작
set autocommit fasle;
    update member set money=10000 - 2000 where member_id = 'memberA';
    update member set money=10000 + 2000 where member_idd = 'memberB';

=> user 1이 쿼리 실행 시 오류가 난다. Column "Member_idd" not found; SQL statement

이 상태에서 강제로 commit; 호출 시에는 memberB의 계좌는 변동없이 memberA의 계좌에서 2000원만 줄어드는 문제가 발생한다.

<case 3 : 계좌 이체 실패 - rollback>
user 1 : 트랜잭션 시작
set autocommit fasle;
    update member set money=10000 - 2000 where member_id = 'memberA';
    update member set money=10000 + 2000 where member_idd = 'memberB';

=> user 1이 쿼리 실행 시 오류가 난다. Column "Member_idd" not found; SQL statement
이 상태에서 commit;하지 않고 rollback;을 수행하면 트랜잭션을 반영하지 않은 기존 데이터가 보여진다.



-------------------------------------------------------------------------------------------------------------------------------------

<DB Lock>
세션 1이 트랜잭션 시작, 데이터 수정하는 사이 세션 1이 커밋을 수행하지 않았는데,
세션 2에서 동시에 같은 데이터를 수정하게 되면 여러 문제가 발생한다. => Atomicity 원자성이 깨진다.
=> 세션이 트랜잭션 시작 이후 데이터를 수정하는 동안에는 commit이나 rollback이 호출되기 전까지 다른 세션에서 해당 데이터를 수정할 수 없게 만들어야 한다.
데이터베이스는 해당 문제를 해결하기 위해 '락 Lock' 개념을 지원한다.

set autocommit true;
    delete from member;
    insert into member(member_id, money) values('memberA', 10000);

1: user 1은 memberA의 money를 10000에서 500으로 바꾸려 한다.
user 1(세션 1)의 Lock 접근 
=> memberA의 money 필드에 있는 Lock에 접근한다.

2: memberA의 money Lock을 user 1이 획득한다.
=> user 1은 memberA의 money를 변경시킬 권한을 얻는다.

3: user 1의 데이터 update
set autocommit false;
    update member set money=500 where member_id  = 'memberA';

//아직 커밋되지 않은 상태이다.


4: user 2의 memberA money 접근 
=> user 2가 memberA의 money에 접근하더라도 user 2는 Lock이 없기 때문에 접근 불가
//user 2는 Lock을 얻기 위해 60초동안 대기, 대기 중 Lock을 얻으면 트랜잭션을 실행한다.
set LOCK_TIMEOUT 60000;
    set autocommit false;
        update member set money = 1000 where member_id = 'memberA'

5: user 1의 Lock 반납
user 1은 commit;을 실행한다 : user 1은 memberA의 money에 대한 Lock을 반납한다. // memberA의 money = 500
user 2는 Lock을 얻기 위해 대기하다 Lock을 얻으면 이후 변경된(commit된) 데이터를 이용해 트랜잭션을 수행한다. //memberA의 money = 1000

6: user 2의 Lock 반납
트랜잭션을 종료한 user 2는 commit; 이후 Lock을 다시 반납한다.

=> 락 개념을 이용하여 원자성 문제 해결


<DB Lock - select 조회>
일반적으로 DB Lock은 데이터 변경 시에 사용한다. (등록, 수정, 삭제)
조회 select는 보통 락을 사용하지 않지만 조회 시에도 DB Lock 사용이 가능하다 : select ~ for update
=> select ... from ... where ... for update 

*중요한 데이터의 경우, 조회 도중 다른 세션이 데이터를 변경(등록, 수정, 삭제)하지 못하도록 막기 위해서 조회에서 Lock을 사용한다.
-select ... for update를 이용하면 조회 도중 Lock을 가지게 되기 때문에 다른 트랜잭션들이 접근하지 못한다.

select * from member where member_id = 'memberA' for update;

-------------------------------------------------------------------------------------------------------------------------------------

<트랜잭션 없이 거래 시>


//트랜잭션을 적용하지 않았을 때 : 예외가 발생하면 정상 처리되지 않는다.
import hello.jdbc.domain.Member;
import hello.jdbc.repository.MemberRepositoryV1;
import lombok.RequiredArgsConstructor;
import java.sql.SQLException;

@RequiredArgsConstructor
public class MemberServiceV1 {
    private final MemberRepositoryV1 memberRespository;

    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Member fromMember = memberRespository.findById(fromId);
        Member toMember = memberRespository.findById(toId);

        memberRespository.update(fromId, fromMember.getMoney() - money);
        validation(toMember);
        memberRespository.update(toId, toMember.getMoney() + money);
    }

    private void validation(Member toMember){
        if(toMember.getMemberId().equals("ex")){
            throw new IllegalStateException("이체 중 예외 발생");
        }
    }
}


//Test
class MemberServiceV1Test {

    public static final String MEMBER_A = "memberA";
    public static final String MEMBER_B = "memberB";
    public static final String MEMBER_EX = "ex";

    private MemberRepositoryV1 memberRespository;
    private MemberServiceV1 memberService;              

    @BeforeEach//test 실행 전 동작되는 코드
    void before(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);
        memberRespository = new MemberRepositoryV1(dataSource);
        memberService = new MemberServiceV1(memberRespository);
    }

    @AfterEach//test 실행 후 동작되는 코드
    void after() throws SQLException{
        memberRespository.delete(MEMBER_A);
        memberRespository.delete(MEMBER_B);
        memberRespository.delete(MEMBER_EX);
    }

    @Test
    @DisplayName("정상 이체")
    void accountTransfer() throws SQLException{

        //given
        Member memberA = new Member(MEMBER_A, 10000);
        Member memberB = new Member(MEMBER_B, 10000);
        memberRespository.save(memberA);
        memberRespository.save(memberB);

        //when
        memberService.accountTransfer(memberA.getMemberId(), memberB.getMemberId(), 2000);

        //then
        Member findMemberA = memberRespository.findById(memberA.getMemberId());
        Member findMemberB = memberRespository.findById(memberB.getMemberId());
        assertThat(findMemberA.getMoney()).isEqualTo(8000);
        assertThat(findMemberB.getMoney()).isEqualTo(12000);
    } //트랜잭션이 없어도 검증 성공, 정상 동작

    @Test
    @DisplayName("이체 중 예외 발생")
    void accountTransferEx() throws SQLException{

        //given
        Member memberA = new Member(MEMBER_A, 10000);
        Member memberEX = new Member(MEMBER_EX, 10000);
        memberRespository.save(memberA);
        memberRespository.save(memberEX);

        //when
        assertThatThrownBy(()->memberService.accountTransfer(memberA.getMemberId(), memberEX.getMemberId(), 2000)).isInstanceOf(IllegalStateException.class);
        //assertThatThrownBy : 예외가 발생하는 것을 검증, 해당 코드는 트랜잭션을 사용하는 것이 아닌 AutoCommit 모드(기본값)이다 : 예외 발생 시 아래 코드들은 실행되지 않음

        //then
        Member findMemberA = memberRespository.findById(memberA.getMemberId());
        Member findMemberEX = memberRespository.findById(memberEX.getMemberId());

        assertThat(findMemberA.getMoney()).isEqualTo(8000);
        assertThat(findMemberEX.getMoney()).isEqualTo(10000);
    }
    //트랜잭션이 없을 때 예외가 발생하면 예외 발생부터 아래 코드들은 동작하지 않는다. 
    //update(...) -> validation(...) -> update(...) 에서 validation 부분에서 예외가 발생하면 이후 update()가 동작하지 않는다.
    //결과적으로 memberA의 잔고는 2000원 감소하였지만 memberB의 잔고는 그대로 유지된다 : 트랜잭션이 없으면 예외 발생 시 데이터 무결성을 해친다.


-------------------------------------------------------------------------------------------------------------------------------------

<트랜잭션 적용 후>

- 트랜잭션을 적용하기 위해서는 비즈니스 로직이 존재하는 서비스 계층에서 적용해야 한다. (비즈니스 로직이 잘못 동작 시 문제되는 부분을 함께 롤백해야 하기 때문)
- 트랜잭션 시작을 위해서는 커넥션이 필요 => 서비스 계층에서 비즈니스 로직과 함께 커넥션을 생성, 트랜잭션 커밋 이후 커넥션을 종료해야 한다. 
- 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야 한다 : 다른 커넥션 사용 시 다른 세션이 사용되기 때문이다 => 커넥션을 파라미터로 전달하는 방식을 이용하여 같은 커넥션 사용

트랜잭션을 적용해야 할 부분
public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Member fromMember = memberRespository.findById(fromId);
        Member toMember = memberRespository.findById(toId);

        memberRespository.update(fromId, fromMember.getMoney() - money);
        validation(toMember);
        memberRespository.update(toId, toMember.getMoney() + money);
    }

-  트랜잭션이 필요한 거래 메서드에서는 update(), findById() 메서드가 사용된다
=> update(), findById() 메서드의 파라미터에 커넥션을 넣어준다 : 같은 커넥션 사용 

import hello.jdbc.domain.Member;
import lombok.extern.slf4j.Slf4j;
import org.springframework.jdbc.support.JdbcUtils;
import javax.sql.DataSource;
import java.sql.*;
import java.util.NoSuchElementException;

@Slf4j
public class MemberRepositoryV2 {

    private final DataSource dataSource;

    //생성자가 하나이기에 AutoWired 자동 적용
    public MemberRepositoryV2(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    public Member save(Member member) throws SQLException {
        String sql = "insert into member(member_id, money) values(?,?)";

        Connection connection = null;
        PreparedStatement preparedStatement = null;

        try{
            connection = getConnection();//커넥션 얻기
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, member.getMemberId());
            preparedStatement.setInt(2, member.getMoney());
            preparedStatement.executeUpdate();
            return member;
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, null);
        }
    }

    public Member findById(String memberId) throws SQLException {
        String sql = "select * from member where member_id = ?";

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try{
            connection=getConnection();
            preparedStatement= connection.prepareStatement(sql);
            preparedStatement.setString(1, memberId);

            resultSet=preparedStatement.executeQuery();

            if(resultSet.next()){
                Member member = new Member();
                member.setMemberId(resultSet.getString("member_id"));
                member.setMoney(resultSet.getInt("money"));
                return member;
            }else{
                throw new NoSuchElementException("member not found memberId=" + memberId);
            }
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, resultSet);
        }
    }

    public Member findById(Connection connection,String memberId) throws SQLException {
        String sql = "select * from member where member_id = ?";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try{
            //connection=getConnection();
            preparedStatement= connection.prepareStatement(sql);
            preparedStatement.setString(1, memberId);

            resultSet=preparedStatement.executeQuery();

            if(resultSet.next()){
                Member member = new Member();
                member.setMemberId(resultSet.getString("member_id"));
                member.setMoney(resultSet.getInt("money"));
                return member;
            }else{
                throw new NoSuchElementException("member not found memberId=" + memberId);
            }
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            //connection은 닫지 않는다.
            JdbcUtils.closeResultSet(resultSet);
            JdbcUtils.closeStatement(preparedStatement);
        }
    }


    public void update(String memberId, int money) throws SQLException {
        String sql = "update member set money =? where member_id = ?";

        Connection connection = null;
        PreparedStatement preparedStatement = null;

        try{
            connection = getConnection();//커넥션 얻기
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, money);
            preparedStatement.setString(2, memberId);

            int resultSize = preparedStatement.executeUpdate();
            log.info("resultSize = " +  resultSize);

        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, null);
        }
    }

    public void update(Connection connection, String memberId, int money) throws SQLException {
        String sql = "update member set money =? where member_id = ?";

        PreparedStatement preparedStatement = null;

        try{
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, money);
            preparedStatement.setString(2, memberId);

            int resultSize = preparedStatement.executeUpdate();
            log.info("resultSize = " +  resultSize);

        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            //connection은 닫지 않는다.
            JdbcUtils.closeStatement(preparedStatement);
        }
    }


    public void delete(String memberId) throws SQLException {
        String sql = "delete from member where member_id=?";

        Connection connection = null;
        PreparedStatement preparedStatement = null;

        try{
            connection = getConnection();//커넥션 얻기
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, memberId);

            preparedStatement.executeUpdate();

        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, null);
        }
    }

    private void close(Connection connection, Statement statement, ResultSet resultSet){
        JdbcUtils.closeResultSet(resultSet);
        JdbcUtils.closeStatement(statement);
        JdbcUtils.closeConnection(connection);
    }

    private Connection getConnection() throws SQLException{
        Connection connection = dataSource.getConnection();
        log.info("get connection={}, class={}", connection, connection.getClass());
        return connection;
    }
}

- 추가된 부분
public Member findById(Connection connection,String memberId) throws SQLException {
        String sql = "select * from member where member_id = ?";

        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try{
            //connection=getConnection(); 커넥션을 외부에서 주입받는다.
            preparedStatement= connection.prepareStatement(sql);
            preparedStatement.setString(1, memberId);

            resultSet=preparedStatement.executeQuery();

            if(resultSet.next()){
                Member member = new Member();
                member.setMemberId(resultSet.getString("member_id"));
                member.setMoney(resultSet.getInt("money"));
                return member;
            }else{
                throw new NoSuchElementException("member not found memberId=" + memberId);
            }
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            //connection은 닫지 않는다.
            JdbcUtils.closeResultSet(resultSet);
            JdbcUtils.closeStatement(preparedStatement);
        }
    }


public void update(Connection connection, String memberId, int money) throws SQLException {
        String sql = "update member set money =? where member_id = ?";

        PreparedStatement preparedStatement = null;

        try{
            //connection=getConnection(); 커넥션을 외부에서 주입받는다.
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, money);
            preparedStatement.setString(2, memberId);

            int resultSize = preparedStatement.executeUpdate();
            log.info("resultSize = " +  resultSize);

        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            //connection은 닫지 않는다.
            JdbcUtils.closeStatement(preparedStatement);
        }
    }

- Repository를 사용하는 Service 계층에서 Connection을 주입받는다 => 같은 커넥션 이용 가능 : 같은 세션 사용
- 커넥션 유지가 필요한 update, findById에서는 리포지토리 계층에서 커넥션을 닫으면 안된다. (이후에도 커넥션을 계속 이어서 사용하기 때문) 
서비스 계층에서 비즈니스 로직이 종료될 때 트랜잭션을 종료한 뒤 커넥션을 닫아야 한다.

<컨트롤러를 사용하는 서비스 계층 로직>

import hello.jdbc.domain.Member;
import hello.jdbc.repository.MemberRepositoryV2;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.SQLException;

@Slf4j
@RequiredArgsConstructor
public class MemberServiceV2 {

    private final DataSource dataSource;
    private final MemberRepositoryV2 memberRepository;

    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Connection connection = dataSource.getConnection();   //공용으로 사용할 커넥션 생성
        try{
            connection.setAutoCommit(false);                  //트랜잭션 시작

            //비즈니스 로직
            bizLogic(connection, fromId, toId, money);
  
            connection.commit();                              //비즈니스 로직 성공 시 커밋
        }catch (Exception e){
            connection.rollback();                            //실패(예외 발생) 시 롤백
            throw new IllegalStateException(e);
        }finally {
            release(connection);                              //비즈니스 로직 종료 후 커넥션 반납
        }
    }
    private void validation(Member toMember){
        if(toMember.getMemberId().equals("ex")){
            throw new IllegalStateException("이체 중 예외 발생");
        }
    }
    public void bizLogic(Connection connection, String fromId, String toId, int money) throws SQLException{
        Member fromMember = memberRepository.findById(connection, fromId);
        Member toMember = memberRepository.findById(connection, toId);

        memberRepository.update(connection, fromId, fromMember.getMoney()-money);
        validation(toMember);
        memberRepository.update(connection, toId, toMember.getMoney()+money);
    }

    private void release(Connection connection){
        if(connection!=null){
            try{
                connection.setAutoCommit(true);    //커넥션 풀에 반환하기 전에 자동 커밋으로 변경
                connection.close();                //커넥션 풀에 커넥션 반환
            }catch(Exception e){
                log.info("errer", e);
            }
        }
    }
}

서비스 계층 Test 코드

import hello.jdbc.domain.Member;
import hello.jdbc.repository.MemberRepositoryV2;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import java.sql.SQLException;
import static hello.jdbc.connection.ConnectionConst.*;
import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.assertj.core.api.AssertionsForClassTypes.assertThatThrownBy;
import static org.junit.jupiter.api.Assertions.*;

class MemberServiceV2Test {
    public static final String MEMBER_A = "memberA";
    public static final String MEMBER_B = "memberB";
    public static final String MEMBER_EX = "ex";

    private MemberRepositoryV2 memberRepository;
    private MemberServiceV2 memberService;

    @BeforeEach
    void before(){
        DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);
        memberRepository = new MemberRepositoryV2(dataSource);
        memberService = new MemberServiceV2(dataSource, memberRepository);
    }

    @AfterEach
    void after() throws SQLException {
        memberRepository.delete(MEMBER_A);
        memberRepository.delete(MEMBER_B);
        memberRepository.delete(MEMBER_EX);
    }

    @Test
    @DisplayName("정상 이체")
    void accountTransfer() throws SQLException{
        //given
        Member memberA = new Member(MEMBER_A, 10000);
        Member memberB = new Member(MEMBER_B, 10000);
        memberRepository.save(memberA);
        memberRepository.save(memberB);

        //when
        memberService.accountTransfer(memberA.getMemberId(), memberB.getMemberId(), 2000);

        //then
        Member findMemberA = memberRepository.findById(memberA.getMemberId());
        Member findMemberB = memberRepository.findById(memberB.getMemberId());
        assertThat(findMemberA.getMoney()).isEqualTo(8000);
        assertThat(findMemberB.getMoney()).isEqualTo(12000);
    }
    //거래 - 예외가 없을 시 정상 동작

    @Test
    @DisplayName("이체 중 예외 발생")
    void accountTransferEx() throws SQLException{
        //given
        Member memberA = new Member(MEMBER_A, 10000);
        Member memberEX = new Member(MEMBER_EX, 10000);
        memberRepository.save(memberA);
        memberRepository.save(memberEX);
        //when
        assertThatThrownBy(()->memberService.accountTransfer(memberA.getMemberId(), memberEX.getMemberId(), 2000)).isInstanceOf(IllegalStateException.class);

        //then
        Member findMemberA = memberRepository.findById(memberA.getMemberId());
        Member findMemberEX = memberRepository.findById(memberEX.getMemberId());

        assertThat(findMemberA.getMoney()).isEqualTo(10000);
        assertThat(findMemberEX.getMoney()).isEqualTo(10000);
    }
    //거래 - 예외 발생 시 트랜잭션의 Rollback 동작

}
