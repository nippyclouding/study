<데이터베이스 사용>
클라이언트 <---> 서버 <---> DB

클라이언트 : 웹 브라우저, 앱 .. 
서버 : WAS (정적 서버가 아닌 동적 서버, Tomcat .. )
DB : MySQL, Oracle, H2 ..
--------------------------------------------------------------------------------------------------
JDBC 등장 이전 서버 to DB 
1 : 커넥션 연결 - WAS가 연결 통로를 생성한다, WAS에 들어있는 커넥션 풀에서 커넥션을 빌려온다.
2 : SQL 전달 - WAS가 SQL을 DB에 전달한다.
3 : DB의 결과 응답
4 : WAS는 DB의 결과를 받아 사용, 이후 DB 작업이 끝나면 빌려온 커넥션을 커넥션 풀에 다시 반납한다.

한계 : 각 DB마다 커넥션 연결 방법, SQL 전달 방법, 결과 응답 방법이 모두 상이하다.
DB 교체 시 관련 코드를 모두 수정해야 하며, 개발자가 매번 각각의 DB에 대해 새로 학습해야 한다. (DIP 위반)

한계 해결 : JDBC 표준 인터페이스 등장 
JDBC : JAVA Database Connectivity, 자바에서 DB에 접속하는 방법을 규정하는 자바 API


JDBC 표준 인터페이스
- java.sql.Connection : 연결
- java.sql.Statement : DB에 전달할 SQL을 담은 내용
- java.sql.ResultSet : DB에서 응답하는 SQL 결과 내용

JDBC 등장 이후 서버 to DB 
1 : 커넥션 연결 - WAS가 연결 통로를 생성한다, JDBC 표준 인터페이스에 맞추어 DB에 연결한다.
2 : SQL 전달 - JDBC의 표준 인터페이스에 맞추어 SQL을 전달한다.
3 : DB의 결과 응답 - JDBC의 표준 인터페이스에 맞추어 결과를 응답한다.
4 : WAS는 DB 결과를 받아 사용한다.

JDBC라는 표준이 등장하며 DB 교체 시 관련 코드를 모두 수정할 필요가 없어졌다.

JDBC 표준 인터페이스 구현체
- MySQl 드라이버, Oracle 드라이버, H2 드라이버 ... 
=> JDBC 표준 인터페이스를 각 DB에 맞게 구현한 것을 JDBC'드라이버' 라고 한다.

JDBC 드라이버 : 각각의 DB가 JDBC 표준 인터페이스에 맞게 작동하도록 구현한 라이브러리
MySQL DB가 JDBC 표준으로 작동하기 위해서는 MySQL JDBC 드라이버를 구현해야 하고, 
Oracle이 JDBC 표준으로 작동하기 위해서는 Oracle JDBC 드라이버가 필요하다.

JDBC 인터페이스와 구현체 드라이버의 등장에도 한계점 : SQL이 DB마다 조금씩 다르다.


이후 기술 개발로 인해 JDBC를 직접 사용하지 않고 JDBC를 편리하게 사용할 수 있는 기술들이 등장하였다.
=> SQL Mapper, ORM
SQL Mapper : JdbcTemplate, MyBatis
ORM : JPA

SQL Mapper, ORM 기술들은 모두 JDBC를 내부적으로 사용하고 있기에 JDBC에 대한 기본적인 이해가 필수이다.

//H2 DB를 먼저 연결해두어야 한다.
public abstract class ConnectionConst {
    public static final String URL = "jdbc:h2:tcp://localhost/~/test";
    public static final String USERNAME = "sa";
    public static final String PASSWORD = "";
}


import lombok.extern.slf4j.Slf4j;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import static hello.jdbc.connection.ConnectionConst.*;
@Slf4j
public class DBConnectionUtil {
    public static Connection getConnection(){
        try{
            //Connection : JDBC 표준 인터페이스가 제공하는 Connection, Statement, ResultSet에서의 Connection
            Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);

            log.info("get connection = {}, class = {}", connection, connection.getClass());

            return connection;
        } catch (SQLException e) {
            throw new IllegalStateException(e);//체크 예외를 런타임 예외로 변경하여 throw
        }
    }
}


Connection getConnection() Test
@Test
void connection(){

    //커넥션 획득 테스트
    Connection connection = DBConnectionUtil.getConnection();
    assertThat(connection).isNotNull(); // null이면 테스트 실패, null이 아니면 테스트 성공
}


=>H2 DB를 실행한 뒤 테스트를 실행하면 connection 내부가 null이 아닌 것을 확인할 수 있다 : 내부에 connection이 들어와있다.

log.info("get connection = {}, class = {}", connection, connection.getClass());
=> DBConncectionUtil - get connection=conn0: url = jdbc:h2:tcp://localhost/~/test user=SA, class=class org.h2.jdbc.JdbcConnection

get connection=conn0: url = jdbc:h2:tcp://localhost/~/test user=SA 
=> url과 user 이름이 출력된다.
class=class org.h2.jdbc.JdbcConnection
=> h2 데이터베이스 드라이버가 제공하는 H2 전용 커넥션이 출력된다.



DBConnectionUtil 클래스의 getConnection 메서드는 아래와 같은 커넥션을 사용한다.(DBConnectionUtil.getConnection() 이용 시)
- Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);

DriverManager.getConnection(URL, USERNAME, PASSWORD)의 동작 순서
1 : getConnection의 파라미터인 URL을 확인하여 현재 설정된 데이터베이스를 확인한다.
2 : JDBC는 해당 DB의 드라이버를 찾는다. (MySQL 드라이버, H2 드라이버 org.h2.Driver .. )
3 : 드라이버는 TCP 소켓을 통해 H2 서버(localhost:9092 기본포트)에 연결, 인증 정보를 통해 DB 접근 권한 확인 후 커넥션을 반환
4 : 반환된 커넥션을 통해 실제 데이터베이스와 커넥션을 맺는다.

--------------------------------------------------------------------------------------------------------------------

JDBC 개발 준비
1 : H2 DB에 접속
2 : SQL로 테이블을 먼저 생성한다.
drop table member if exists cascade;
create table member(
                       member_id varchar(10),
                       money integer not null default 0,
                       primary key (member_id)
);
3 : 회원 도메인 클래스 생성
import lombok.Data;
@Data
public class Member {
    private String memberId;
    private int money;
    public Member() {
    }
    public Member(String memberId, int money) {
        this.memberId = memberId;
        this.money = money;
    }
}

4 : DB에 접근할 수 있는 리포지토리 클래스 생성 : MemberRespository
import hello.jdbc.connection.DBConnectionUtil;
import hello.jdbc.domain.Member;
import lombok.extern.slf4j.Slf4j;
import java.sql.*;
import java.util.NoSuchElementException;
@Slf4j
public class MemberRepositoryV0{ ... }

5 : MemberRespository에 커넥션 연결, 해제 메서드 생성

* 회원 등록, 조회, 수정, 삭제 로직 구현 시 DB 연결 시 Connection -> Statement -> ResultSet 순서로 자원을 획득할 예정이다.
=> DB 연결을 종료할 때 닫는 순서는 ResultSet -> Statement -> Connection으로 반드시 자원 획득 순서의 역순으로 닫아야 한다.

* 회원 등록, 조회, 수정, 삭제 로직 구현 시 Statement 인터페이스를 상속하는 PreparedStatement 인터페이스를 사용할 예정이다.

JDBC 표준 인터페이스
- java.sql.Connection : 연결
- java.sql.Statement : DB에 전달할 SQL을 담은 내용
- java.sql.ResultSet : DB에서 응답하는 SQL 결과 내용

1)커넥션을 안전하게 반환하는 메서드
private void close(Connection connection, Statement statement, ResultSet resultSet){ 
//JDBC가 제공하는 표준 인터페이스 : Connection, Statement, ResultSet 를 파라미터로 가진다.
        if(resultSet!=null){
            try{
                resultSet.close();
            }catch (SQLException e){
                log.info("error", e);
            }
        }
        if(statement!=null){
            try{
                statement.close();
            }catch (SQLException e){
                log.info("error",e);
            }
        }
        if(connection!=null){
            try{
                connection.close();
            }catch (SQLException e){
                log.info("error", e);
            }
        }
    }

2)커넥션을 연결하는 메서드
private Connection getConnection(){
    return DBConnectionUtil.getConnection();
    //내부적으로 Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); 를 수행, 커넥션 리턴
}




--------------------------------------------------------------------------------------------------------------------



JDBC를 직접 이용한 개발

1. JDBC 개발 - 등록
public Member save(Member member) throws SQLException {
    String sql = "insert into member(member_id, money) values(?,?)";
    Connection connection = null;
    PreparedStatement preparedStatement = null;
  
    try{
        connection = getConnection();                          //1 : 커넥션 얻기
        preparedStatement = connection.prepareStatement(sql);  //2 : values(?, ?)에 들어갈 값 바인딩
        preparedStatement.setString(1, member.getMemberId());
        preparedStatement.setInt(2, member.getMoney());
        preparedStatement.executeUpdate();                     //3 : 쿼리를 DB에 전달, 리턴 값은 쿼리 영향을 받은 row의 갯수(담는 공간이 따로 없다.)
        return member;
    } catch (SQLException e) {
        log.error("db error", e);
        throw e;
    }finally {
        close(connection, preparedStatement, null);    
    }
}

테스트 : 
Member member = new Member("memberV0", 10000);
       repository.save(member);

* PreparedStatement는 Statement를 상속한다.
* PreparedStatement는 DB에 쿼리를 전달하는 역할을 담당한다.
* preparedStatement.executeUpdate() : 커넥션을 통해 실제 연결된 DB에 쿼리를 전달한다, 리턴 : int타입, 영향을 받은 row(열) 수가 리턴된다.
* executeUpdate는 INSERT, UPDATE, DELETE, CREATE, DROP 등 데이터 구조 변경 시에 사용되며, executeQuery와 다르게 사용된다.
* 자원 획득 순서 : Connection -> PreparedStatement, ResultSet은 null이다 => 자원을 닫는 순서는 역순 : PreparedStatement -> Connection
* sql 속 values(?, ?)에서 PreparedStatement의 setString(1, memer.getMemberId()), setInt(2, member.getMoney())를 통해 바인딩 //SQL injection 예방


2. JDBC 개발 - 조회
public Member findById(String memberId) throws SQLException {
    String sql = "select * from member where member_id = ?";

    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;

    try{
        connection=getConnection();                           //1 : 커넥션 얻기
        preparedStatement= connection.prepareStatement(sql);  //2 : select ... where .. = ? 에 들어갈 값 바인딩
        preparedStatement.setString(1, memberId);

        resultSet=preparedStatement.executeQuery();           //3 : 쿼리를 DB에 전달, ResultSet(쿼리 결과를 담는 객체)을 리턴한다.

        if(resultSet.next()){                                 //4 : 쿼리가 반영된 DB 결과를 ResultSet이 가져와 조회할 데이터를 조회 
            Member member = new Member();                   
            member.setMemberId(resultSet.getString("member_id"));
            member.setMoney(resultSet.getInt("money"));
            return member;
        }else{
            throw new NoSuchElementException("member not found memberId=" + memberId);
        }
    } catch (SQLException e) {
        log.error("db error", e);
        throw e;
    }finally {
        close(connection, preparedStatement, resultSet);
    }
}

테스트 : 
Member findMember = repository.findById(member.getMemberId());
log.info("findMember={}", findMember);
assertThat(findMember).isEqualTo(member);

*ResultSet은 JDBC가 제공하는 표준 인터페이스이며 쿼리 실행의 '결과 데이터 테이블' 이다. (행, 열 표 모양이 자료구조)
*executeQuery는 executeUpdate와 다르게 select문을 사용한 조회에서 사용되며, 리턴으로 ResultSet 객체를 반환한다.
*ResultSet은 내부적으로 cursor(커서)를 가지고 있으며 이 커서로 쿼리 결과 중 필요한 데이터를 애플리케이션 로직에 반환한다.
*executeQuery는 select문으로, 여러 결과가 조회될 수 있으며 결과가 여러 개일 경우 ResultSet의 cursor를 while 문으로 돌려야 한다. 현재 findById()는 pk인 Id를 이용해 조회하기에 쿼리 결과가 항상 하나여서 while 대신 if를 사용한다.
*resultSet.next() : resultSet은 맨 처음에는 아무것도 가리키지 않기 때문에 next()를 수행하여 ResultSet 내부의 첫 번째 데이터로 이동해야 한다. //next() 수행 시 계속 다음 데이터로 넘어간다.
*resultSet.getString("member_id")는 현재 커서가 가리키고 있는 위치의 DB 테이블 column명에 속하는 데이터를 String으로 가져온다.
*resultSEt.getInt("money")는 현재 커서가 가리키고 있는 위치의 DB 테이블 column명에 속하는 데이터를 int로 가져온다.

3. JDBC 개발 - 수정
public void update(String memberId, int money) throws SQLException {
    String sql = "update member set money =? where member_id = ?";

    Connection connection = null;
    PreparedStatement preparedStatement = null;

    try{
        connection = getConnection();                           //1 : 커넥션 얻기
        preparedStatement = connection.prepareStatement(sql);   //2 : update ... set .. =? where .. = ?에 들어갈 값 바인딩
        preparedStatement.setInt(1, money);
        preparedStatement.setString(2, memberId);

        int resultSize = preparedStatement.executeUpdate();     //3 : 쿼리를 DB에 전달, 리턴 값은 쿼리 영향을 받은 row의 갯수 
        log.info("resultSize = " +  resultSize);

    } catch (SQLException e) {
        log.error("db error", e);
        throw e;
    }finally {
        close(connection, preparedStatement, null);
    }
}

테스트 : 
repository.update(member.getMemberId(), 20000);
Member updateMember = repository.findById(member.getMemberId());
assertThat(updateMember.getMoney()).isEqualTo(20000);

4. JDBC 개발 - 삭제

public void delete(String memberId) throws SQLException {
    String sql = "delete from member where member_id=?";

    Connection connection = null;
    PreparedStatement preparedStatement = null;

    try{
        connection = getConnection();                           //1 : 커넥션 얻기
        preparedStatement = connection.prepareStatement(sql);   //2 : delete ... where ... = ? 에 들어갈 값 바인딩
        preparedStatement.setString(1, memberId);

        preparedStatement.executeUpdate();                      //3 : 쿼리를 DB에 전달, 리턴 값은 쿼리 영향을 받은 row의 갯수(담는 공간이 따로 없다.)

    } catch (SQLException e) {
        log.error("db error", e);
        throw e;
    }finally {
        close(connection, preparedStatement, null);
    }
}

테스트 : 
repository.delete(member.getMemberId());
assertThatThrownBy(()-> repository.findById(member.getMemberId())).isInstanceOf(NoSuchElementException.class);




--------------------------------------------------------------------------------------------------------------------
최종 코드 MemberRepositoryV0

import hello.jdbc.connection.DBConnectionUtil;
import hello.jdbc.domain.Member;
import lombok.extern.slf4j.Slf4j;

import java.sql.*;
import java.util.NoSuchElementException;

@Slf4j
public class MemberRepositoryV0{

    public Member save(Member member) throws SQLException {
        String sql = "insert into member(member_id, money) values(?,?)";

        Connection connection = null;
        PreparedStatement preparedStatement = null;

        try{
            connection = getConnection();//커넥션 얻기
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, member.getMemberId());
            preparedStatement.setInt(2, member.getMoney());
            preparedStatement.executeUpdate();
            return member;
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, null);
        }
    }

    public Member findById(String memberId) throws SQLException {
        String sql = "select * from member where member_id = ?";

        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try{
            connection=getConnection();
            preparedStatement= connection.prepareStatement(sql);
            preparedStatement.setString(1, memberId);

            resultSet=preparedStatement.executeQuery();

            if(resultSet.next()){
                Member member = new Member();
                member.setMemberId(resultSet.getString("member_id"));
                member.setMoney(resultSet.getInt("money"));
                return member;
            }else{
                throw new NoSuchElementException("member not found memberId=" + memberId);
            }
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, resultSet);
        }
    }

    public void update(String memberId, int money) throws SQLException {
        String sql = "update member set money =? where member_id = ?";

        Connection connection = null;
        PreparedStatement preparedStatement = null;

        try{
            connection = getConnection();//커넥션 얻기
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setInt(1, money);
            preparedStatement.setString(2, memberId);

            int resultSize = preparedStatement.executeUpdate();
            log.info("resultSize = " +  resultSize);

        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, null);
        }
    }

    public void delete(String memberId) throws SQLException {
        String sql = "delete from member where member_id=?";

        Connection connection = null;
        PreparedStatement preparedStatement = null;

        try{
            connection = getConnection();//커넥션 얻기
            preparedStatement = connection.prepareStatement(sql);
            preparedStatement.setString(1, memberId);

            preparedStatement.executeUpdate();

        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        }finally {
            close(connection, preparedStatement, null);
        }
    }

    //커넥션을 닫는 메서드
    private void close(Connection connection, Statement statement, ResultSet resultSet){

        if(resultSet!=null){
            try{
                resultSet.close();
            }catch (SQLException e){
                log.info("error", e);
            }
        }

        if(statement!=null){
            try{
                statement.close();
            }catch (SQLException e){
                log.info("error",e);
            }
        }

        if(connection!=null){
            try{
                connection.close();
            }catch (SQLException e){
                log.info("error", e);
            }
        }

    }

    //커넥션을 연결하는 메서드
    private Connection getConnection(){
        return DBConnectionUtil.getConnection();
    }
}

--------------------------------------------------------------------------------------------------------------------
Test 최종 코드
import hello.jdbc.domain.Member;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;

import java.sql.SQLException;
import java.util.NoSuchElementException;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.junit.jupiter.api.Assertions.*;

@Slf4j
class MemberRepositoryV0Test {

    Repository repository = new MemberRepositoryV0();

    @Test
    void crud() throws SQLException {
        Member member = new Member("memberV0", 10000);
        repository.save(member);


        Member findMember = repository.findById(member.getMemberId());
        log.info("findMember={}", findMember);
        assertThat(findMember).isEqualTo(member);

        repository.update(member.getMemberId(), 20000);
        Member updateMember = repository.findById(member.getMemberId());
        assertThat(updateMember.getMoney()).isEqualTo(20000);

        repository.delete(member.getMemberId());
        assertThatThrownBy(()-> repository.findById(member.getMemberId())).isInstanceOf(NoSuchElementException.class);

    }
}
