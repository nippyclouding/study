V2 모델의 한계 : 서블릿 종속
public interface ControllerV2 {
    MyView process(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;
}

ControllerV2를 구현하는 MemberForm, MemberSave, MemberList 컨트롤러 모두 process 메서드에 HttpServletRequest request, HttpServletResponse response가 있다.
문제는 HttpServletRequest request, HttpServletResponse response를 사용하지 않으면서도 가지고 있다는 것이다.

V2 모델의 개선 : 뷰 네임 중복, 공통 부분이 많다.
return new MyView("/WEB-INF/views/new-form.jsp");
return new MyView("/WEB-INF/views/save-result.jsp");
return new MyView("/WEB-INF/views/members.jsp");

해결 : V3 모델
=> ModelView 전용 객체를 이용하여 서블릿 종속 부분을 Map으로 다루고, 공통 뷰 네임을 논리 이름으로 설계하도록 한다.

- 모델 뷰 객체
@Getter @Setter
public class ModelView {

    private String viewName; // 논리 이름을 받아온다.
    private Map<String, Object> model = new HashMap<>(); // String 타입의 request 객체 이름, Object 타입의 request 객체를 담는다.

    public ModelView(String viewName) {
        this.viewName = viewName;
    }
}


- MyView 객체
public class MyView {
    private String viewPath;

    //뷰 객체를 생성할 때 경로를 함께 받는다.
    public MyView(String viewPath) {
        this.viewPath = viewPath;
    }

    //V2 전용 render 메서드
    //myview.render을 통해 view를 요청 객체에 전달하여 응답을 생성
    public void render(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{
        RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
        dispatcher.forward(request, response);
    }

    //V3 전용 render 메서드, 모델을 파라미터로 받고 렌더링 
    public void render(Map<String, Object> model, HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException{

        //model 내부 데이터를 RequestAttribute에 담는다. (뷰로 전달하기 위한 요청 객체 속 자료구조)
        model.forEach((key, value) -> req.setAttribute(key, value));

        RequestDispatcher dispatcher = req.getRequestDispatcher(viewPath);
        dispatcher.forward(req, resp);
    }
}

public interface ControllerV3 {
    ModelView process(Map<String, String> paramMap); //파라미터 = username, age가 담겨있는 map, process 사용 시 리턴 타입 = ModelView (내부에 map이 있다.)
}

public class MemberFormControllerV3 implements ControllerV3{
    @Override
    public ModelView process(Map<String, String> paramMap) {
        return new ModelView("new-form"); //논리 이름 반환
    }
}

public class MemberSaveControllerV3 implements ControllerV3{
    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    public ModelView process(Map<String, String> paramMap) {
        String username = paramMap.get("username");
        int age = Integer.parseInt(paramMap.get("age"));

        //요청 map에서 정보를 추출하여 객체 생성, DB에 저장
        Member member = new Member(username, age);
        memberRepository.save(member);

        //모델뷰 객체 생성, jsp 파일 논리 이름 적용 후 member 객체를 담아 리턴
        ModelView mv = new ModelView("save-result");
        mv.getModel().put("member", member);
        return mv;
    }
}

public class MemberListControllerV3 implements ControllerV3{

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    public ModelView process(Map<String, String> paramMap) {
        List<Member> members = memberRepository.findAll();
        ModelView mv = new ModelView("members");
        mv.getModel().put("members", members);

        return mv;
    }


@WebServlet(name = "frontControllerServletV3", urlPatterns = "/front-controller/v3/*")
public class FronControllerServletV3 extends HttpServlet {
    private Map<String, ControllerV3> controllerMap = new HashMap<>();

    //프론트 컨트롤러로 요청이 올 경우 jsp 경로를 key로, 경로에 해당하는 컨트롤러를 value로 설정하여 생성
    public FronControllerServletV3(Map<String, ControllerV3> controllerMap) {
        controllerMap.put("/front-controller/v3/members/new-form", new MemberFormControllerV3());
        controllerMap.put("/front-controller/v3/members/save", new MemberSaveControllerV3());
        controllerMap.put("/front-controller/v3/members", new MemberListControllerV3());
    }

    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //요청 객체 속 URI를 조회
        String requestURI = req.getRequestURI();
        //map에서 key인 String uri를 통해 value를 조회
        ControllerV3 controller = controllerMap.get(requestURI);

        //검증
        if(controller==null){
            resp.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        //컨트롤러 정상 조회 성공 시
        //req에 담긴 정보들을 모두 paramMap에 담는다.
        Map<String, String> paramMap = new HashMap<>();
        req.getParameterNames().asIterator().forEachRemaining(paramName -> paramMap.put(paramName, req.getParameter(paramName)));

        //모델 뷰 객체를 생성해서 paramMap을 객체에 담는다.
        ModelView mv = controller.process(paramMap);

        //모델 뷰에서 뷰 물리 name 조회, myview 객체
        String viewName = mv.getViewName();
        MyView view = viewResolver(viewName);

        //뷰 객체에서 jsp 파일을 렌더링
        view.render(mv.getModel(), req, resp);


    }

    //뷰의 논리 이름 -> 물리 이름으로 바꾸는 메서드
    private MyView viewResolver(String viewName) {
        return new MyView("/WEB-INF/views/" + viewName + ".jsp");
    }
}
