Adapter 패턴 도입
V1 ~ V4 모델 중 원하는 모델을 사용 가능


public interface MyHandlerAdapter {
    //Object handler = 컨트롤러
    //어댑터가 파라미터로 넘어온 컨트롤러를 처리할 수 있는지 판단
    boolean support(Object handler);

    //프론트 컨트롤러가 아닌 어댑터가 Member save, form, list 컨트롤러 호출, ModelView 객체에 넣어 리턴
    ModelView handle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws ServletException, IOException;
}





public class ControllerV1HandlerAdapter implements MyHandlerAdapter {
    @Override
    public boolean support(Object handler) {
        return (handler instanceof ControllerV1);
    }

    @Override
    public ModelView handle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws ServletException, IOException {
        ControllerV1 controller = (ControllerV1) handler;
        controller.process(req, resp);

        // V1은 직접 뷰를 렌더링하므로 어댑터에서 ModelView로 변환이 어렵다.
        // 보통은 null을 리턴하거나, 기본 ModelView를 생성해서 리턴
        // 어댑터 패턴으로 ModelView를 리턴하는 구조와 맞지 않는다.
        // V1을 어댑터로 감싸는 것은 설계상 부자연스럽다.
        return null;
    }
}


public class ControllerV2HandlerAdapter implements MyHandlerAdapter {
    @Override
    public boolean support(Object handler) {
        return (handler instanceof ControllerV2);
    }

    @Override
    public ModelView handle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws ServletException, IOException {
        ControllerV2 controller = (ControllerV2) handler;
        MyView view = controller.process(req,resp);
        ModelView mv = new ModelView(view.getViewPath());
        return mv;
    }
}



public class ControllerV3HandlerAdapter implements MyHandlerAdapter {
    @Override
    public boolean support(Object handler) {
        //파라미터로 넘어온 컨트롤러(핸들러)가 V3 타입 객체가 맞는지 판단
        return (handler instanceof ControllerV3);
    }

    @Override
    public ModelView handle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws ServletException, IOException {
        //파라미터로 넘어온 Object 타입 핸들러(컨트롤러) 다운캐스팅
        ControllerV3 controller = (ControllerV3) handler;

        //컨트롤러 정상 조회 성공 시
        //req에 담긴 정보들을 모두 paramMap에 담는다.
        Map<String, String> paramMap = new HashMap<>();
        req.getParameterNames().asIterator().forEachRemaining(paramName -> paramMap.put(paramName, req.getParameter(paramName)));

        //Member Save, list, form 컨트롤러가 요청 정보를 처리한 뒤 뷰를 ModelView 객체에 담아서 리턴
        ModelView mv = controller.process(paramMap);
        return mv;
    }
}



public class ControllerV4HandlerAdapter implements MyHandlerAdapter {
    @Override
    public boolean support(Object handler) {
        return (handler instanceof ControllerV4);
    }

    @Override
    public ModelView handle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws ServletException, IOException {
        //파라미터로 넘어온 Object 타입 핸들러(컨트롤러) 다운캐스팅
        ControllerV4 controller = (ControllerV4) handler;

        //컨트롤러 정상 조회 성공 시
        //req에 담긴 정보들을 모두 paramMap에 담는다.
        Map<String, String> paramMap = new HashMap<>();
        Map<String, Object> model = new HashMap<>();

        //Member Save, list, form 컨트롤러가 요청 정보를 처리, 리턴으로 뷰 논리 이름
        //process 메서드 수행 수 담아둘 Model 객체까지 함께 전달한다.
        String viewName = controller.process(paramMap, model);
        ModelView mv = new ModelView(viewName);
        return mv;
    }
}



@WebServlet(name = "frontControllerServletV5", urlPatterns = "/front-controller/*")
public class FrontControllerServletV5 extends HttpServlet {

    //컨트롤러를 담는 Map
    private final Map<String, Object> handlerMappingMap = new HashMap<>();

    //각 버전에 해당하는 어댑터들을 담는 List
    private final List<MyHandlerAdapter> handlerAdapters = new ArrayList<>();

    //요청이 올 경우 Map에 먼저 핸들러(컨트롤러)들을 모두 넣어둔다.
    public FrontControllerServletV5() {
        handlerMappingMap.put("/front-controller/v5/v1/members/new-form", new MemberFormControllerV1());
        handlerMappingMap.put("/front-controller/v5/v1/members/save", new MemberSaveControllerV1());
        handlerMappingMap.put("/front-controller/v5/v1/members", new MemberListControllerV1());

        handlerMappingMap.put("/front-controller/v5/v2/members/new-form", new MemberFormControllerV2());
        handlerMappingMap.put("/front-controller/v5/v2/members/save", new MemberSaveControllerV2());
        handlerMappingMap.put("/front-controller/v5/v2/members", new MemberListControllerV2());

        handlerMappingMap.put("/front-controller/v5/v3/members/new-form", new MemberFormControllerV3());
        handlerMappingMap.put("/front-controller/v5/v3/members/save", new MemberSaveControllerV3());
        handlerMappingMap.put("/front-controller/v5/v3/members", new MemberListControllerV3());

        handlerMappingMap.put("/front-controller/v5/v4/members/new-form", new MemberFormControllerV4());
        handlerMappingMap.put("/front-controller/v5/v4/members/save", new MemberSaveControllerV4());
        handlerMappingMap.put("/front-controller/v5/v4/members", new MemberListControllerV4());
    }

    //List에 각 버전의 어댑터를 추가한다.
    private void initHandlerAdapters(){
        handlerAdapters.add(new ControllerV1HandlerAdapter());
        handlerAdapters.add(new ControllerV2HandlerAdapter());
        handlerAdapters.add(new ControllerV3HandlerAdapter());
        handlerAdapters.add(new ControllerV4HandlerAdapter());
    }

    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //요청 정보에서 URI 조회
        String requestURI = req.getRequestURI();
        //요청 URI에 해당하는 컨트롤러를 조회
        Object handler = handlerMappingMap.get(requestURI);

        //컨트롤러(핸들러)가 정상적으로 조회되었는지 검증
        if(handler==null){
            resp.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        //처리 가능한 어댑터인지 어댑터 리스트에서 조회(검증)
        MyHandlerAdapter adapter = null;
        for(MyHandlerAdapter temp : handlerAdapters){
            if(temp.support(handler))
                adapter = temp;
        }

        //검증 통과 시 요청 정보에 해당하는 뷰를 ModelView 객체에 담고 렌더링
        ModelView mv = adapter.handle(req, resp, handler);
        MyView view = viewResolver(mv.getViewName());
        view.render(mv.getModel(), req, resp);
    }

    private MyView viewResolver(String viewName) {
        return new MyView("/WEB-INF/views/" + viewName + ".jsp");
    }
}
