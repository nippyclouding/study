V3의 개선 : 매번 요청이 올 때마다 ModelView 객체를 생성해야 한다. (Save, Form, List 컨트롤러는 요청 시 매번 ModelView 리턴 필요)

해결 : Save, Form, List 컨트롤러에서 매번 return new ModelView(...);가 아니라
FrontController에서 ModelView를 생성하여 Save, Form, List 컨트롤러에 전송


public interface ControllerV4 {
    //요청 시 처리 메서드에 사용자의 정보가 담긴 paramMap만 전달하는 것이 아닌
    //process 메서드 수행 수 담아둘 Model 객체까지 함께 전달한다.
    //리턴 = 뷰의 논리 이름
    String process(Map<String, String> paramMap, Map<String, Object> model);
}

public class MemberFormControllerV4 implements ControllerV4{
    @Override
    public String process(Map<String, String> paramMap, Map<String, Object> model) {
        //리턴 = 뷰의 논리 이름
        return "new-form";
    }
}

public class MemberSaveControllerV4 implements ControllerV4{
    @Override
    public String process(Map<String, String> paramMap, Map<String, Object> model) {
        String username = paramMap.get("username");
        int age = Integer.parseInt(paramMap.get("age"));

        //요청 map에서 정보를 추출하여 객체 생성, DB에 저장
        Member member = new Member(username, age);
        memberRepository.save(member);

        model.put("member", member);

        //리턴 = 뷰의 논리 이름
        return "save-result";
    }
}


public class MemberListControllerV4 implements ControllerV4{

    private MemberRepository memberRepository = MemberRepository.getInstance();

    @Override
    public String process(Map<String, String> paramMap, Map<String, Object> model) {
        List<Member> members = memberRepository.findAll();
        //model을 직접 생성하지 않고 프론트 컨트롤러에서 전달받는다.
        model.put("members", members);

        //리턴 = 뷰의 논리 이름
        return "members";
    }
}

@WebServlet(name = "frontControllerServletV3", urlPatterns = "/front-controller/v3/*")
public class FrontControllerServletV4 extends HttpServlet {
    private Map<String, ControllerV4> controllerMap = new HashMap<>();

    //프론트 컨트롤러로 요청이 올 경우 jsp 경로를 key로, 경로에 해당하는 컨트롤러를 value로 설정하여 생성
    public FrontControllerServletV4(Map<String, ControllerV4> controllerMap) {
        controllerMap.put("/front-controller/v4/members/new-form", new MemberFormControllerV4());
        controllerMap.put("/front-controller/v4/members/save", new MemberSaveControllerV4());
        controllerMap.put("/front-controller/v4/members", new MemberListControllerV4());
    }

    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //요청 객체 속 URI를 조회
        String requestURI = req.getRequestURI();
        //map에서 key인 String uri를 통해 value를 조회
        ControllerV4 controller = controllerMap.get(requestURI);

        //검증
        if(controller==null){
            resp.setStatus(HttpServletResponse.SC_NOT_FOUND);
            return;
        }

        //컨트롤러 정상 조회 성공 시
        //req에 담긴 정보들을 모두 paramMap에 담는다.
        //paramMap : 요청 정보를 처리하기 위한 map
        Map<String, String> paramMap = new HashMap<>();
        req.getParameterNames().asIterator().forEachRemaining(paramName -> paramMap.put(paramName, req.getParameter(paramName)));

        //각 컨트롤러에서 모델을 생성하지 않고 프론트 컨트롤러에서 모델을 생성하여 파라미터로 전달한다.
        Map<String, Object> model = new HashMap<>();

        //모델 뷰에서 뷰 물리 name 조회, myview 객체
        String viewName = controller.process(paramMap, model);
        MyView view = viewResolver(viewName);

        //뷰 객체에서 jsp 파일을 렌더링
        view.render(model, req, resp);
    }

    //뷰의 논리 이름 -> 물리 이름으로 바꾸는 메서드
    private MyView viewResolver(String viewName) {
        return new MyView("/WEB-INF/views/" + viewName + ".jsp");
    }
}

