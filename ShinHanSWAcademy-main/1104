의존 모듈 (라이브러리) 관리
JAR (java archive) : 클래스를 모아둔 것

dependency : 
프로젝트 생성 : gradle, maven 프로젝트가 있다 // gradle, maven : 빌드 도구, 의존 라이브러리를 자동으로 관리한다. (lombok 등 필요한 의존성을 자동으로 클래스 패스 등에 저장, 연결한다.)
빌드 : 테스트, 컴파일, 외부 dependency 관리, 패키징(JAR, WAR로 만들기) 모두 빌드이다.
빌드 : 소스 코드를 실행 가능한 파일로 변환하는 과정

스프링 레거시 프로젝트에서는 maven, 스프링 부트 프로젝트에서는 gradle로 프로젝트 진행 예정

예외처리 : 프로그램이 중단되지 않게 하기 위해, 특정 예외 발생 시 알기 위해, 디버깅 용도 ..

String.valueOf() 사용 (String 클래스)
null 가능성이 있는 객체, String.valueOf(null) 시 "null"로 변환
기본 타입 변환
안전한 문자열 변환이 필요할 때

toString() 사용 (Object 클래스)
객체가 null이 아님이 확실할 때, toString(null) 시 오류 발생
커스텀 toString() 구현을 명시적으로 호출할 때

byte[] 배열로 String 생성
String str = new String (byte[] bytes); // 네트워크에서 바이트 배열을 String으로 바꾸는 경우가 있다.

----------------------------------------------------------------------------------------
public class EX23 {
    public static void main(String[] args) throws UnsupportedEncodingException {
        String s = "Java";

        byte[] arr1 = s.getBytes(); //생략 시 기본값 - UTF-8
        System.out.println("arr1: " + Arrays.toString(arr1));

        byte[] arr2 = s.getBytes("EUC-KR");
        System.out.println("arr2 = " + Arrays.toString(arr2));


        String sArr = new String(arr1); //생략 시 기본값 - UTF-8
        System.out.println("sArr = " + sArr);

        String sArr2 = new String (arr2, "EUC-KR");
        System.out.println("sArr2 = " + sArr2);

    }
}

출력
arr1: [74, 97, 118, 97]
arr2 = [74, 97, 118, 97]
sArr = Java
sArr2 = Java

object.toString() : 객체 주솟값 출력
Arrays.toString(), 또는 오버라이딩한 toString() : 실제 필드 내용 출력

----------------------------------------------------------------------------------------
StringBuilder : 더 빠른 조작 기능이 필요할 때 사용 (StringBuffer도 있지만 스레드 환경에서 동기화를 보장하지 않는다.) 
잦은 문자열 변경 작업이 필요하다면 불변성을 가지는 String보다 StringBuilder을 사용하는 것이 좋다.
StringBuilder은 내부 버퍼를 가지고 있기 때문에 내부에 문자열을 저장, 수정 작업을 한다.

public class EX24 {
    public static void main(String[] args) {
        String s = "hello";
        StringBuilder sb = new StringBuilder();
        sb.append("abcd");
        //System.out.println(sb); StringBuilder 타입
        System.out.println(sb.toString()); //String 타입


        StringBuilder sb2 = new StringBuilder(s);
        sb2.append("abcd");
        System.out.println(sb2.toString()); //s에 "abcd"를 더한다.
    }
}

출력
abcd
helloabcd
----------------------------------------------------------------------------------------
StringTokenizer : 구분자로 연결된 문자열을 분리할 때 사용 

public class EX24 {
    public static void main(String[] args) {
        String s = "3 1 9";
        StringTokenizer st = new StringTokenizer(s, " ");
        while(st.hasMoreTokens()) System.out.println(st.nextToken()); //st.nextToken()은 st가 토큰을 더 가지고 있을 때 다음 토큰을 출력
    }
}

출력
3
1
9

----------------------------------------------------------------------------------------

package ShinHan.study;

import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.HashSet;
import java.util.Set;

public class EX26 {
    public static void main(String[] args) {
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy.MM.dd a HH:mm:ss"); // a : 오전

        LocalDateTime startDateTime = LocalDateTime.now();
        System.out.println("startDateTime.format(dtf) = " + startDateTime.format(dtf));

        LocalDateTime endDateTime = LocalDateTime.of(2026, 4, 21, 0, 0, 0); //신한 SW 종료일
        System.out.println("startDateTime.format(dtf) = " + startDateTime.format(dtf));

        if(startDateTime.isBefore(endDateTime)) System.out.println("진행 중입니다.");
        else if(startDateTime.isEqual(endDateTime)) System.out.println("종료합니다.");
        else if(startDateTime.isAfter(endDateTime)) System.out.println("종료했습니다.");

        long remainYear = startDateTime.until(endDateTime, ChronoUnit.YEARS);
        long remainMonth = startDateTime.until(endDateTime, ChronoUnit.MONTHS);
        long remainDay = startDateTime.until(endDateTime, ChronoUnit.DAYS);
        long remainHour = startDateTime.until(endDateTime, ChronoUnit.HOURS);
        long remainMinute = startDateTime.until(endDateTime, ChronoUnit.MINUTES);
        long remainSecond = startDateTime.until(endDateTime, ChronoUnit.SECONDS);

        System.out.println("remainYear = " + remainYear);
        System.out.println("remainMonth = " + remainMonth);
        System.out.println("remainDay = " + remainDay);
        System.out.println("remainHour = " + remainHour);
        System.out.println("remainMinute = " + remainMinute);
        System.out.println("remainSecond = " + remainSecond);
    }
}

출력
startDateTime.format(dtf) = 2025.11.04 오전 11:50:21
startDateTime.format(dtf) = 2025.11.04 오전 11:50:21
진행 중입니다.
remainYear = 0
remainMonth = 5
remainDay = 167
remainHour = 4020
remainMinute = 241209
remainSecond = 14472578

----------------------------------------------------------------------------------------
정규식 - 파이썬의 텍스트 데이터에서 자주 사용된다.

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class EX27 {
    public static void main(String[] args) {

        //먼저 컴파일 후 확인
        Pattern p = Pattern.compile("b[a-z]*"); //문자 b로 시작하며 소문자 a~z중 하나, 앞의 문자가 0개 이상 반복(*)

        Matcher m = p.matcher("bat"); //b로 시작하기에 패턴 일치 
        System.out.println(m.matches());
        System.out.println(p.matcher("cat").matches()); //c로 시작하기에 패턴 불일치


        //전화번호 추출
        String source = "안녕하세요 저는 홍길동인데요, 제 전화번호는 010-1234-5678입니다. 계좌번호는 123-4566-0123";
        //자릿수 번호로 가져오기 어렵다
        p = Pattern.compile("(0\\d{1,2})-(\\d{3,4})-(\\d{4})");

        m=p.matcher(source);
        while(m.find()) System.out.println(m.group()); //정규식에 해당되는 문자열들을 모두 추출한다.
    }
}
----------------------------------------------------------------------------------------
리플렉션 : 런타임에 클래스의 정보를 조사하고 조작할 수 있는 기능

Java는 클래스와 인터페이스의 메타 정보를 Class 객체로 관리한다.
메타 정보 : 패키지 정보, 타입 정보, 생ㅅ엉자, 필드, 메서드 정보 등을 의미
리플렉션 : 메타 정보를 런타임에 프로그램에서 읽고 수정하는 행위

Hello hello = new Hello();

Class clazz = Hello.class;
Class clazz = Class.forName("ShinHan.study.Hello");
Class clazz = hello.getClass();

Class<Hello> clazz = Hello.class;    //타입 안전
Class<?> clazz = Class.forName("ShinHan.study.Hello");
Class<?> clazz = hello.getClass();

윈도우의 최상위 경로는 드라이브(c드라이브, d드라이브), 유닉스와 리눅스는 최상위가 /이다.

----------------------------------------------------------------------------------------
Annotation

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class EX28 {
    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException {
        Method[] declaredMethods = Service.class.getDeclaredMethods();
        for(Method m : declaredMethods){
            PrintAnnotation pa = m.getAnnotation(PrintAnnotation.class);
            printLine(pa);
            m.invoke(new Service());
            printLine(pa);
        }
    }

    private static void printLine(PrintAnnotation pa) {
        if(pa!=null){
            int num = pa.number();
            for(int i=0; i<num; i++){
                String value = pa.value();
                System.out.print(value);
            }
            System.out.println();
        }
    }

    public static class Service{
        @PrintAnnotation
        public void method1(){
            System.out.println("실행 내용 1");
        }
        @PrintAnnotation("*")
        public void method2(){
            System.out.println("실행 내용 2");
        }
        @PrintAnnotation(value = "#", number = 20)
        public void method3(){
            System.out.println("실행 내용 3");
        }
    }
    
    @Target(ElementType.METHOD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface PrintAnnotation{
        String value() default "-";
        int number() default 15;
    }

}

----------------------------------------------------------------------------------------
제네릭 : 타입을 강제시킨다.

import lombok.Getter;
import lombok.Setter;

public class EX29 {

    public static void main(String[] args) {
        Product<Tv, String> produce1 = new Product<>();
        produce1.setKind(new Tv());
        produce1.setModel("smart tv");
        System.out.println(produce1.model);
        
        Product<Car, String> produce2 = new Product<>();
        produce2.setKind(new Car());
        produce2.setModel("new Car");
        System.out.println(produce2.model);
    }

    @Getter @Setter
    public static class Product<K, M>{
        private K kind;
        private M model;
    }

    public static class Tv{}
    public static class Car{}
}


----------------------------------------------------------------------------------------
멀티 스레드

