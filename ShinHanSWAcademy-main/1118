1118 TUE

1차 프로젝트 시 mybatis로 진행한다. (sql을 직접 짠다) => mybatis의 동적 쿼리 제작 능력을 발휘할 수 있는 프로젝트를 설계해보자.
성능 테스트까지 꼭 하기
프로젝트 시 오라클보다는 마리아DB로 하는 것이 좋다.

--------------------------------------------------------------------------
복습
트랜잭션
- 가상의 논리적인 하나의 작업 단위
- all or nothing
- dml 실행하는 순간 트랜잭션이 시작
- 트랜잭션 종료 : commit, rollback (commit : 적용, rollback : 취소)
- 트랜잭션 단위 : 세션 (접속)
- lock : 다른 세션에서 변경 작업중이면 현재 세션에서는 변경 작업 시도 시 락을 건다.
- 프로그램 연동 시 autocommit 또는 autocommit 비활성화 후 작업이 끝나면 commit 
- 예외 발생 시 rollback

DDL data definition language 데이터 정의 언어 : 객체를 생성, 수정, 삭제

인덱스 
- 조회를 빠르게 하기 위해 사용 (update, delete 등 성능은 낮아진다)
- 특정 컬럼값 별도의 공간에 정렬해서 저장한다.
- 일반적으로 데이터 조회, 정렬 등 기능은 실무에서는 java application에서 사용하지 않고 DB에서 모두 해결한다.
- 실무에서는 인덱스를 직접 생성하기보다, 실행 계획을 확인할 경우가 많다. 


-----------------------------------------------------------------------------------------------------
<뷰>
사용 이유 
- 편리성, 보안성
- 빠른 속도
join이 많으면 성능이 낮아진다.
=> join에 대한 select문을 미리 view로 만들어두고, view 조회 시 join을 하지 않고 바로 select문을 가져오기 때문에 빠른 속도 처리가 된다.

//뷰, 인덱스, 시퀀스 문제

-- 1번
create table empdix 
as select * from emp;
select * from empdix;
create index IDX_EMPIDX_EMPNO on empdix(empno);

--인덱스 - idx_empidx_empno 조회 시 보여진다.
select * from user_indexes;

--2번
create view temp as(
select empno, ename, job, deptno, sal, 
        case 
        when comm is null then 'O' else 'X'
        end as comm
from emp
where sal > 1500);


--3번
create table deptseq as select * from dept;
create sequence seq_dept_deptno; -- 기본값으로 생성
insert into deptseq values (seq_dept_deptno.nextval, 'DATABASE', 'SEOUL');
insert into deptseq values (seq_dept_deptno.nextval, 'WEB', 'BUSAN');
insert into deptseq values (seq_dept_deptno.nextval, 'MOBILE', 'ILSAN');


외래키
- 다른 테이블과 조인할 목적으로 사용
- FK : 엄격, 무결성이 정확해야 한다, 비즈니스 로직의 유연성 감소 (업무 유연성 감소) // FK : 식별 관계 
- 일반 컬럼 : 엄격하지 않다, 무결성 위험, 비즈니스 로직의 유연성 증대 // 일반 키 : 비식별 관계


사용자 계정 생성
-- orclstudy 사용자 계정 생성
create user ORCLSTUDY identified by ORACLE;
-- 세션 생성 권한을 제공 (접속 권한 부여)
grant create session to ORCLSTUDY;

-- orclstudy 사용자에게 testuser 스키마의 dept 조회 권한을 부여한다.
grant select on testuser.dept to orclstudy;
-- orclstudy 사용자에게 testuser 스키마의 dept 조회 권한을 회수한다.
revoke select on testuser.dept from orclstudy;


PL/SQL : SQL의 확장된 개념, 오라클에서 지원, 함수와 프로시저를 만들 수 있다.
근래에 잘 사용하지 않는 이유 : 오라클에 종속적이며, 함수/프로시저 기능은 비즈니스 로직에서 구현한다.

----------------------------------------------------------------------------------------------------------------
<ERD>
https://www.erdcloud.com/
내 ERD 가입 계정 : nippyclouding@gmail.com

데이터 모델링
- 데이터 설계
- 대상 (업무 프로세스)
- 대상을 이해하고 규칙을 정의

엔티티 : 관리되어야 할 데이터의 집합
속성 : 데이터의 가장 작은 논리적 단위
- 단일 속성 : 하나의 속성 (id, pw, 이름 ..)
- 복합 속성 : 주소 (~시, ~구, ~동) // 필드가 서로 다르다.
- 다중 속성 : 같은 종류의 필드가 여러개 (취미 - 낚시, 야구 ..)

특성에 따른 종류
- 기본 속성 : 원래 속성
- 설계 속성 : 설계(모델링) 중에 추가되는 속성 (ex : pk , 주문 고유 번호 ..)
- 파생 속성 : 다른 속성에 의해 추가되는 속성

관계 
- 두 엔티티 간의 관계
1:1 일대일 
1:N 일대다
N:M 다대다

식별관계 : PK 안에 FK가 포함되는 관계 (FK ⊆ PK)
ex : 주문상품은 주문번호(FK)가 기본키(PK)에 포함되어 부모(주문)에 의해 식별

비식별관계 : FK는 있지만 PK와는 별개인 관계 (FK ∉ PK)
ex : 게시글은 작성자ID(FK)를 참조하지만 기본키(PK)는 독립적이다.

정규화 
- 데이터 일관성, 중복 최소화, 유연성을 위해 데이터를 분해하는 과정
1정규화 : PK 설정하기
2정규화 : Key가 2개 이상인 속성으로 인해서 분해
3정규화 : PK를 제외한 다른 속성으로 분해

EX
회원 : id, userName, email, pw ..
상품 : itemName, price, itemInfo .. // 상품 옵션은 필드로 두는 것이 아니라 다른 엔티티로 두어야 한다.
주문 : orderDate, orderPrice, userName, item .. 

주문 테이블은 order로 정하면 안된다. (sql의 order by와 겹친다)
------------------------------------------------------------------------------------------------------------------------------------------------------
<Maria DB>

-- 페이징 처리

-- 1페이지는 0번 인덱스부터 10개 // 2페이지는 10번 인덱스부터 10개 ...
SELECT * FROM dept
ORDER BY deptno
LIMIT 0, 10; -- limit 5; : 5개 제한 출력 

-- 날짜 관련 함수
SELECT SYSDATE();
SELECT NOW();

SELECT DATEDIFF('2025-12-31', NOW()); -- 날짜 간 일수 

SELECT DATE_ADD(NOW(), INTERVAL 10 DAY); -- 날짜 이후
SELECT DATE_SUB(NOW(), INTERVAL 10 DAY); -- 날짜 이전
SELECT DATE_ADD(NOW(), INTERVAL -10 DAY); -- add로 날짜 이전 구하기

SELECT DATE_FORMAT(NOW(), '%Y-%m-%d'); -- 날짜 포멧팅

SELECT salary + IFNULL(bonus, 0) FROM emp; -- 널처리

SELECT if(salary>=1000, 'A', 'B') FROM emp;

SELECT CONCAT(ename, ':', job) FROM emp; -- 문자열 합치기, 오라클과 같이 ||는 사용 불가

SELECT * FROM MEMBER WHERE id LIKE '%on%'; -- 오라클과 다르게 like 검색 시 대소문자 구분을 하지 않는다.

-- 오라클과 다르게 mysql, mariadb는 sequence 대신 auto increment가 있다.
-- 테이블 생성 시 테이블의 pk 열에 auto increment 속성 지정


상품 - 카테고리는 n:m 관계이다.
하나의 상품이 여러 카테고리에 들어가 있을 수 있다. (컴퓨터, 인문 ..)
하나의 카테고리에 여러 상품이 들어가 있을 수 있다. (컴퓨터1, 컴퓨터2 ..)
