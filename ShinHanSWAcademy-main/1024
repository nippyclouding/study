1024 FRI

배운 내용 정리는 노션도 괜찮다.
스터디, 자격증 준비 고려
JDK 8이 오래된 기준점, 17이 현대 기준점
이클립스 JDK 변경법 : 시스템 변수 - 변경할 JDK 이름으로 설정

JDK 파일은 자주 사용하는 각 버전들을 하나의 디렉토리에서 관리하는 것이 좋다.
JDK를 설치한 파일은 경로를 함부로 변경하면 안된다.
JDK 설치, 환경변수 설정도 스스로 할 줄 알아야 한다.
환경 변수를 수정하면 기존 명령 프롬프트 또는 터미널에서 바로 적용되는 것이 아니라 종료 후 재실행 필요

빌드 : 실행하고자 하는 결과물을 만드는 과정 (소스 코드를 실행 가능한 결과물로 만드는 과정)
빌드 속에 컴파일 과정이 포함되어있다.
이클립스에서 프로젝트 우클릭 - properties - java build path의 Source 항목에 들어가면
하단에 Default output folder이 존재한다. 
해당 경로가 빌드 파일이 생성되는 위치이다. (기본 : 프로젝트명/bin)

타입 추론 : 지역 변수 선언 시 var로 자료형을 사용한다면 타입이 자동으로 추론, 결정된다
변수 선언 시 a, b 같은 변수명보다 의미있는 변수명을 사용하도록 습관을 들이자.

character set = 문자 집합, 한글이 들어있지 않은 문자 집합도 있기 때문에 가능하면 한글을 사용하지 말고 변수명, 클래스명 등을 작성하기
자바, 파이썬 등 대부분의 언어들은 기본적으로 UTF-8이다.
메모장 인코딩 방식이 ANSI인데 UTF-8로 열게 된다면 인코딩에 오류가 생긴다. 

<자료형>
byte : 1바이트, 값 범위 : -2의 7제곱 ~ 2의 7제곱-1
short : 2바이트, 값 범위 : -2의 15제곱 ~ 2의 15제곱-1
char : 2바이트, 값 범위 : 0 ~ 2의 16제곱-1
int : 4바이트, 값 범위 : -2의 31제곱 ~ 2의 31제곱-1
float : 4바이트
long : 8바이트, 값 범위 : -2의 63제곱 ~ 2의 63제곱-1
double : 8바이트

float h = 3.14f; //float는 끝에 F나 f를 써야 한다.
double hh = 3.14;
실무에서는 float 대신 double을 사용

byte a = 10;
byte b = 20;
byte c = a + b; //컴파일 에러
=> 연산이 일어나게 되면 int로 형변환되기 때문에 컴파일 에러가 발생한다. (type mismatch)
byte, char, short, int 타입들은 연산을 하게 되면 int 타입으로 자동으로 형변환된다.

<형변환>
short < int < long < double
short는 int로도, long으로도 업캐스팅 될 수 있다. 
int는 long으로 업캐스팅 될 수 있다.
long은 double로 업캐스팅 될 수 있다.
업캐스팅 = 작은 자료형들은 큰 자료형에 담을 수 있다.
작은 자료형 -> 큰 자료형으로 담으면 자동으로 형변환
다운캐스팅 = 큰 자료형들은 작은 자료형에 담기 위해 명시적으로 형변환을 해야 한다.
long k = 10;
int a = (int) k;


<String>
String n = ""; // 빈 문자열
String n2 = " " // 공백 
String n3 = null // 값 없음

String s1 = "a";
String s2 = "a";
System.out.println(s1==s2); //true
리터럴로 String을 사용하면 문자열 상수풀을 사용하여 비교하여 true가 나온다.
s1은 상수풀 속의 "a"를 가리키고, s2도 상수풀 속의 "a"를 가리킨다.
같은 주소를 가리키기에 true가 나온다.

String s3 = new String("hello");
String s4 = new String("hello");
System.out.println(s3==s4); //false
객체로 String을 선언하면 메모리의 주소값 속에 자료가 저장되어 s3==s4는 주솟값을 비교한다.
String n = "3" + 1; // n은 "31"이 된다. // 문자열 + 숫자 = 문자열이 된다.

다른 타입 -> String 변환 : String.valueOf()는 다른 타입의 자료형을 String으로 변환시킨다.
String -> 다른 타입 변환
String -> byte : Byte.parseByte()
String -> short : Short.paserShort()
String -> int : Integer.parseInt()
String -> double : Double.paserDouble()
String -> boolean : Boolean.parseBoolean()

문자열 String은 == 비교가 아니라 .equals()로 비교한다.
.equals()로 값을 비교한다. (String의 ==는 주솟값 비교)
.equals() 사용 시 "q".equals(data) 처럼 보여지는 문자열을 앞으로 먼저 배치하는 것이 좋은 습관이다.

자료형 = 기본 자료형(primitive), 참조 자료형(reference)
기본 자료형 = 정수, 실수, 논리형, 문자
참조 자료형 = 문자열, 배열, 클래스 .. 

<JSON>
JavaScript Object Notation
데이터 통신 포맷 (송수신 방식)
[] : 배열
{} : 객체

<Scanner>
Scanner sc = new Scanner(System.in);
String s = sc.nextLine();
nextLine() : enter 키를 누르면 입력된 문자열을 읽는다. (문자 전체)
next() : 공백(" "), tab, enter 키를 인식하면 입력된 문자를 읽는다. (한 단어)

<이클립스의 단축키>
ctrl shift o : 자동 import
ctrl alt 방향키 : 지정 영역 자동 복사
shift enter : 라인 추가 및 줄바꿈
라인 이동 : alt 방향키 (위아래)
ctrl d : 라인 삭제

.jar 파일 = java Archive 파일
.clss 파일이 .jar 파일 안으로 들어간다. (.java -> .class)

global 변수 = 전역 변수
member 변수 = class에 속한 변수, 클래스 변수라고도 한다.
local 변수 = 지정된 구간(괄호) 속에서만 사용 가능한 변수

연산자 - 증감, 산술, 비교, 논리, 대입, 삼항
int kor = 90;
int eng = 80;
int math = 80;
double avg = kor + eng + math / 3; //정수 간 연산은 정수 결과만 나온다, 83.3333이 아닌 83.0이 출력된다. (주의하기)
kor, eng, math 변수 중 하나가 정수가 아닌 실수로 선언되면 정상적인 결과가 나온다.

오버플로우 : 타입이 허용하는 최댓값을 벗어나는 경우
언더플로우 : 타입이 허용하는 최소값을 벗어나는 경우
byte value = 127 //최댓값
value++; //value는 -128로 최솟값이 된다.

<예외>
error : 개발자가 해결할 수 없는 오류
exception : error 이외의 오류
- 체크 예외
- 언체크 예외 (런타임 예외)

Throwable
    |     \
Exception, Error
    |
checked Exception, unchecked Exception
                            |
                    runtime Exception
                            |      
     nullPointerEx, ArrayIndexOutBoundsEx, NumberFormatEx


try, catch, finally : 예외 발생 시 프로그램의 종료를 막고 정상 실행을 유지할 수 있도록 한다.
- 예외 발생이 없을 경우 : try문에서 예외가 없다면 바로 finally로 간다. 
- 예외 발생 시 : try문에서 예외 발생 시 catch문으로 넘어갔다 finally로 간다.


public class Main {
    public static void main(String[] args){
        System.out.println("프로그램 시작");
        printLength("This is java");
        printLength(null);
        System.out.println("프로그램 종료");
    }

    private static void printLength(String data) {
        int result = data.length();
        System.out.println("문자 수 : result");
    }
}

<결과>
프로그램 시작
문자 수 : result
Exception in thread "main" java.lang.NullPointerException: Cannot invoke "String.length()" because "data" is null
	at Main.printLength(Main.java:13)
	at Main.main(Main.java:8)

- try문은 예외가 발생 가능한 구간에 적용할 수 있다.

public class Main {
    public static void main(String[] args){
        System.out.println("프로그램 시작");
        printLength("This is java");
        printLength(null);
        System.out.println("프로그램 종료");
    }

    private static void printLength(String data) {
        try{
            int result = data.length();
            System.out.println("문자 수 : " + result);
        }catch (NullPointerException e){
            e.printStackTrace(System.out);
        }finally {
            System.out.println("마무리 실행");
        }
    }
}

프로그램 시작
문자 수 : 12
마무리 실행
java.lang.NullPointerException: Cannot invoke "String.length()" because "data" is null
	at Main.printLength(Main.java:14)
	at Main.main(Main.java:8)
마무리 실행
프로그램 종료


